<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>双指针</title>
      <link href="/2023/11/14/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2023/11/14/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1>双指针</h1><h5 id="前言">前言</h5><blockquote><p>《算法导论》上是看不到的双指针的，因为无论是思考过程还是代码实现上都是非常容易理解，所以各大算法书上都不屑将它归为算法，但是它却作为职场面试，省赛水题的绝佳选择，它有一个比较优雅的名字叫 尺取法，英文把它叫 “two pointers”，也就是 “双指针” 的意思。</p></blockquote><h2 id="一、最长不重复子串">一、最长不重复子串</h2><blockquote><p>给定一个长度为 n (1 ≤ n ≤ 10^7^) 的字符串 s，求一个最长的满足所有字符不重复的子串。</p></blockquote><h3 id="1、初步分析">1、初步分析</h3><p>首先我们分析一下这个问题的关键词，主要有以下几个：</p><p><strong>1）n ≤ 10^7^；</strong></p><p><strong>2）最长；</strong></p><p><strong>3）所有字符不重复；</strong></p><p><strong>4）子串；</strong></p><p>根据以上的几个关键词，我们可以得出一些结论。首先，根据 n 的范围已经能够大致确认这是一个需要 O(n) 或者 O(nlogn) 的算法才能解决的问题；其次，“最长” 这个词告诉我们，可能是一个动态规划问题或者贪心问题，也有可能是搜索，所以这个关键词给我们的信息用处不大；而判断字符是否重复可以用 哈希表 在 O(1) 的时间内判断；最后，枚举所有 “子串” 的时间复杂度是 O(n^2) 的。</p><h3 id="2、朴素算法">2、朴素算法</h3><p>由以上分析，我们可以发现第（1）个 和 第（4）个关键词给我们得出的结论是矛盾的，那么，我们可以先尝试减小 n 的范围，如果 n ≤ 1000 时，怎么解决这个问题呢？</p><p>因为最后求的是满足条件的最长子串，所以我们如果能够枚举所有子串，那么选择长度最长的满足条件的子串就是答案了（这里的条件是指子串中所有字符都不同）。</p><blockquote><p>用 ans 记录我们需要求的最大不重复子串的长度，用一个哈希表 h 来代表某个字符是否出现过，算法描述如下：</p><p>1）枚举子串的左端点 i = 0 -&gt; n-1；</p><p>2）清空哈希表 h；</p><p>3）枚举子串的右端点 j = i -&gt; n-1，如果当前这个字符 s[j] 出现过（即 h[ s[j] ] 为 true），则跳出 j 的循环；否则，令 h[ s[j] ] 为 true，并且用当前长度去更新 ans（即 ans= max(ans, j - i +1) ）；</p><p>4）回到 2）；</p></blockquote><p>c语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getmaxlen</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, i, j, len;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 1)</span></span><br><span class="line">        j = i;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="literal">false</span>, <span class="keyword">sizeof</span>(h)); <span class="comment">// 2)</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; !h[str[j]]) &#123;</span><br><span class="line">            h[ str[j] ] = <span class="literal">true</span>; <span class="comment">// 3)</span></span><br><span class="line">            len = j - i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; ans)</span><br><span class="line">                ans = len, l = i, r = j;</span><br><span class="line">            ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）这一步枚举对应子串的左端点 i；</p><p>2）这一步用于清空哈希表 h，其中 h[ s[j] ] 为 true 代表原字符串的第 j 个字符 s[j] 是否出现在以第 i 个字符为左端点的子串中；</p><p>3）而第三步可以这么理解：如果字符串 s[i:j] 中已经出现重复的字符，那么 s[i:j+1]，s[i:j+2], … , s[i:n-1] 必然会有重复字符，所以这里不需要继续往下枚举，直接跳出第二层循环即可。</p><p>这个算法执行完毕，ans 就是我们要求的最长不重复子串的长度，[l, r] 代表了最长不重复子串在原字符串的区间。正确性毋庸置疑，因为已经枚举了所有子串的情况，如果字符集的个数 z，算法的时间复杂度就是 O(nz)。</p><p>最后奉上一张动图，代表了上述朴素算法的求解过程，如图所示：</p><img src="../img/Fus0YmnXxIbGxqSTLKgrhI-Nb6zT.gif" alt="Fus0YmnXxIbGxqSTLKgrhI-Nb6zT" style="zoom:80%;" /><p>字符串下标从 0 开始，最长无重复子串为：s[1:5] = bcaed，长度为 5。</p><p>由于是字符串，字符集的个数 z 最多 256，所以时间复杂度基本就是 O(256n)，当 n ≤ 10^7 时，这个时间复杂度是无法接受的，需要想办法优化。</p><h3 id="3、优化算法">3、优化算法</h3><p>如果仔细思考上面朴素算法的求解过程，就会发现：枚举子串的时候有很多区间是重叠的，所以必然存在许多没有必要的重复计算。</p><p>我们考虑一个子串以 s[i] 为左端点，s[j] 为右端点，且 s[i:j-1] 中不存在重复字符，s[i:j] 中存在重复字符（换言之，s[j] 和 s[i:j-1] 中某个字符相同）。</p><p>那么我们没必要再去检测 s[i:j+1]，s[i:j+2]，s[i:n-1] 这几个字符串的合法性，因为当前情况 s[i:j] 是非法的，而这些字符串是完全包含 s[i:j] 的，所以它们必然也是不合法的。</p><p>那么我们可以把枚举的左端点自增，即： i = i +1，这时，按照朴素算法的实现，右端点需要重置，即 j = i，而实际上这里的右端点可以不动。</p><p>可以这么考虑，由于 s[j] 这个字符和 s[i:j-1] 中的字符产生了重复，假设这个重复的字符的下标为 k，那么 i 必须满足 i ≥ k，换言之， i 可以一直自增，直到 i = k+1，如图所示</p><img src="../img/Ftq7MR4620P64r4tIr6EYWwDwkGP.gif" alt="Ftq7MR4620P64r4tIr6EYWwDwkGP" style="zoom:80%;" /><p>利用上述思路，我们重新实现 最长不重复子串 的算法，C语言代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getmaxlen</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">-1</span>, len; <span class="comment">// 1)</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h)); <span class="comment">// 2)</span></span><br><span class="line">    <span class="keyword">while</span> (j++ &lt; n - <span class="number">1</span>) &#123; <span class="comment">// 3)</span></span><br><span class="line">        ++h[ str[j] ]; <span class="comment">// 4)</span></span><br><span class="line">        <span class="keyword">while</span> (h[ str[j] ] &gt; <span class="number">1</span>) &#123; <span class="comment">// 5)</span></span><br><span class="line">            --h[ str[i] ];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        len = j - i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; ans) <span class="comment">// 6)</span></span><br><span class="line">        ans = len, l = i, r = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）初始化 i = 0, j = -1，代表 s[i:j] 为一个空串，从空串开始枚举；</p><p>2）同样需要维护一个哈希表，哈希表记录的是当前枚举的区间 s[i:j] 中每个字符的个数；</p><p>3）只推进子串的右端点；</p><p>4）在哈希表中记录字符的个数；</p><p>5）当 h[ str[j] ] &gt; 1 满足时，代表出现了重复字符，这时候左端点 i 推进，直到没有重复字符为止；</p><p>6）记录当前最优解 j-i+1；</p><p>这个算法执行完毕，我们就可以得到最长不重复子串的长度为 ans，并且 i 和 j 这两个指针分别只自增 n 次，两者自增相互独立，是一个相加而非相乘的关系，所以这个算法的时间复杂度为 O(n) 。</p><p>利用该优化算法优化后的最长不重复子串的求解过程如图所示：</p><img src="../img/FjJ4MKsh0soAU40CEh5Pf5puZOqq.gif" alt="FjJ4MKsh0soAU40CEh5Pf5puZOqq" style="zoom:80%;" /><p>参考这个图，一个比较通俗易懂的解释：当区间 [i, j] 中存在重复（红色）字符时，左指针 i 自增；否则，右指针 j 自增。</p><h2 id="二、双指针">二、双指针</h2><h3 id="1、算法定义">1、算法定义</h3><p>如上文所述，这种利用问题特性，通过两个指针，不断调整区间，从而求出问题最优解的算法就叫 “尺取法”，由于利用的是两个指针，所以又叫 “双指针” 算法。</p><p>这里 “尺” 的含义，主要还是因为这类问题，最终要求解的都是连续的序列（子串），就好比一把尺子一样，故而得名。</p><h3 id="2、算法描述">2、算法描述</h3><blockquote><p>算法描述如下：</p><p>1）初始化 i=0, j=i-1，代表一开始 “尺子” 的长度为 0；</p><p>2）增加 “尺子” 的长度，即 j = j +1；</p><p>3）判断当前这把 “尺子” [i, j] 是否满足题目给出的条件：</p><p>3.a）如果不满足，则减小 “尺子” 长度，即 i = i + 1，回到 3）；</p><p>3.b）如果满足，记录最优解，回到 2）；</p></blockquote><p>上面这段文字描述的比较官方，其实这个算法的核心，只有一句话：</p><p><strong>满足条件时，j++；不满足条件时，i++；</strong></p><p>如图所示，当区间 [i, j] 满足条件时，用蓝色表示，此时 j 自增；反之闪红，此时 i 自增。</p><img src="../img/FgwnGM2aUC7Cur0Oy-uasQ84N7iW.gif" alt="FgwnGM2aUC7Cur0Oy-uasQ84N7iW" style="zoom:80%;" /><h3 id="3、条件">3、条件</h3><p>这里所说的条件比较模糊，对于【例题1】来说，条件就是 “字符不重复”，当然也可以是 “每个字符重复次数不超过 k 次”，“至少包含 k 种字符”，“求和不大于 k” 等等，因题而异。</p><p>然而，无论问题怎么变，这里的条件都需要满足以下两点：</p><h4 id="1）单调性">1）单调性</h4><p>所谓单调性，就是说：任意一个指针的增加，条件满足与否只会出现两种情况，即 ： 【满足 -&gt; 不满足】或者 【不满足 -&gt; 满足】，不会出现 【满足 -&gt; 不满足 -&gt; 满足】这样的情况。</p><h4 id="2）时效性">2）时效性</h4><p>所谓时效性，就是说：必须在 O(1) 或者 O(log_2n) 的时间内，求出当前区间 [i, j] 是否满足既定条件，否则无法用这种算法求解。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心</title>
      <link href="/2023/11/12/%E8%B4%AA%E5%BF%83/"/>
      <url>/2023/11/12/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1>贪心</h1><h4 id="一、概念定义"><strong>一、概念定义</strong></h4><p>所谓贪心，总是做出在当前看来是最好的选择。也就是说，不从整体最优上进行考虑，算法得到的是在某种意义上的局部最优解。</p><p>比如，对于一个全是正整数的数组，我要找到其中两个数，使得它们的乘积最大，毫无疑问，一定是取 <strong>最大</strong> 和 <strong>次大</strong> 的两个数进行相乘，得到的结果最大。这个就是贪心思想。</p><p>贪心是一种抽象的算法，需要的不仅仅是积累，往往还有灵光一现。</p><h4 id="二、例题分析"><strong>二、例题分析</strong></h4><p><strong>1、最大乘积差</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProductDifference</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);<span class="comment">//先对数组进行排序</span></span><br><span class="line">    <span class="keyword">return</span> nums[numsSize - <span class="number">1</span>] * nums[numsSize - <span class="number">2</span>] - nums[<span class="number">0</span>] * nums[<span class="number">1</span>];<span class="comment">//利用贪心，直接取最大的两个数下标作为 w 和 x，最小的两个数下标作为 y 和 z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、三角形的最大周长</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">largestPerimeter</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = numsSize - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>] + nums[i<span class="number">-2</span>]) <span class="comment">//利用三角形两边之和大于第三边的性质，假设小的两条边为 a 和 b，大的那条为 c，那么必须满足如下等式才能满足它是一个三角形： a + b &gt; c</span></span><br><span class="line">            <span class="keyword">return</span> nums[i] + nums[i<span class="number">-1</span>] + nums[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题要求最大的三角形周长，那么势必是最大的那条边 c 越大越好，所以我们可以枚举将所有的边按照递增排序，然后逆序枚举最大的那条边 c，去剩下的边里找小的两条边，最好的情况肯定是比 c 小的最大和次大边最优，如果这两条边都不能满足上述不等式，剩下的边也就肯定也不满足了，所以只需要一个循环即可解决问题。</p><p><strong>3、分发饼干</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>* g, <span class="type">int</span> gSize, <span class="type">int</span>* s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = gSize, n = sSize;</span><br><span class="line">    qsort(g, m, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    qsort(s, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);<span class="comment">//分别对 胃口值 和 饼干 都进行递增排序</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i++, j++) &#123;<span class="comment">//然后将两个游标都指向 胃口值 和 饼干 的开头</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; g[i] &gt; s[j]) &#123;  <span class="comment">//不满足，饼干 的游标往后移动一格，寻找更加容易满足条件的解，直到 饼干 或者 胃口值 枚举完毕</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n) &#123;<span class="comment">//如果某一个 饼干 和 胃口值 满足条件，则答案加一</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、练习"><strong>三、练习</strong></h4><p><a href="https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs/">两个数对之间的最大乘积差</a></p><p><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">三角形的最大周长</a></p><p><a href="https://leetcode.cn/problems/array-partition/">数组拆分</a></p><p><a href="https://leetcode-cn.com/problems/boats-to-save-people/">救生艇</a></p><p><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/">摆动排序 II</a></p><p><a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></p><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-increasing/">最少操作使数组递增</a></p><p><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/">使数组唯一的最小增量</a></p><p><a href="https://leetcode-cn.com/problems/valid-triangle-number/">有效三角形的个数</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递推</title>
      <link href="/2023/11/09/%E9%80%92%E6%8E%A8/"/>
      <url>/2023/11/09/%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<h1>递推</h1><h2 id="前言">前言</h2><blockquote><p>递推最通俗的理解就是数列，递推和数列的关系就好比 算法 和 数据结构 的关系，数列有点像数据结构中的顺序表，而递推就是一个循环或者迭代的枚举过程。</p><p>递推本质上是数学问题，所以有同学问算法是不是需要数学非常好，也并不是，你会发现，这些数学只不过是初中高中我们学烂的东西，高考都经历了，这些东西又何足为惧！?</p></blockquote><h2 id="一、斐波那契数列">一、斐波那契数列</h2><blockquote><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1</p><p>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1，给定 n(0 ≤ n ≤ 30) ，请计算 F(n) 。</p></blockquote><p>拿到这个题目，我们首先来看题目范围， 最多不超过 30，那是因为斐波那契数的增长速度很快，是指数级别的。所以如果  n 很大，就会超过 c语言 中32位整型的范围。这是一个最基础的递推题，递推公式都已经告诉你了，我们要做的就是利用一个循环来实现这个递推。</p><p>我们只需要用一个 F[31] 数组，初始化好 F[0] 和 F[1]，然后按照给定的公式循环计算就可以了。像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// (1)</span></span><br><span class="line">    <span class="type">int</span> F[<span class="number">31</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; ++i) &#123; <span class="comment">// (3)</span></span><br><span class="line">        F[i] = F[i<span class="number">-1</span>] + F[i<span class="number">-2</span>]; <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F[n]; <span class="comment">// (5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>(1) 首先定义一个循环变量；</li><li>(2) 再定义一个数组记录斐波那契数列的第 n 项，并且初始化第 0 项 和 第 1 项。</li><li>(3) 然后一个 for 循环，从第 2 项开始；</li><li>(4) 利用递推公式逐步计算每一项的值；</li><li>(5) 最后返回第 n 项即可。</li></ol><h2 id="二、泰波那契数列">二、泰波那契数列</h2><blockquote><p>泰波那契序列 Tn 定义如下：</p><p>T(0) = 0, T(1) = 1, T(2) = 1</p><p>且在 n &gt; 2 的条件下 T(n) = T(n-1) + T(n-2) + T(n-3)，给你整数 n，请返回第 n 个泰波那契数 T(n) 的值。</p></blockquote><p>如果已经理解斐波那契数列，那么这个问题也不难，只不过初始化的时候，需要初始化前三个数，并且在循环迭代计算的时候，当前数的值需要前三个数的值累加和。像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> T[<span class="number">100</span>];</span><br><span class="line">    T[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    T[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    T[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    T[i] = T[i<span class="number">-1</span>] + T[i<span class="number">-2</span>] + T[i<span class="number">-3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、斐波那契数列变形">三、斐波那契数列变形</h2><blockquote><p>给定一个 n(1 ≤ n ≤ 45) 代表总共有 n 阶楼梯，一开始在第 n 阶，每次可以爬 1 或者 2 个台阶，问总共有多少种不同的方法可以爬到楼顶。</p></blockquote><p>我们定义一个数组 f[46]，其中 f[i] 表示从第  0 阶爬到第 i  阶的方案数。由于每次可以爬 1 或者 2 个台阶，所以对于第 i 阶楼梯来说，所以要么是从第 i-1 阶爬过来的，要么是从 i-2  阶爬过来的。</p><p>于是得出一个递推公式：f[i] = f[i-1] + f[i-2]。</p><p>我们发现这个就是斐波那契数列，你可以叫它递推公式，也可以叫它状态转移方程。这里的 f[i]  就是状态的概念，从一个状态到另一个状态就叫状态转移。</p><p>当然我们还要考虑初始状态，f[0] 代表从第 0 阶到第 0 阶的方案数，当然就是 1 啦，f[1] 代表从第 0 阶到第 1 阶的方案数，由于只能走 1 阶，所以方案数也是 1。</p><p>代码就不再累述了。</p><h3 id="四、二维递推问题">四、二维递推问题</h3><p>像斐波那契数列这种问题，是一个一维的数组来解决的，有些时候，一维解决不了的时候，我们就需要升高一个维度来看问题了。</p><blockquote><p>长度为 n(1≤n&lt;40) 的只由 ‘A’、‘C’、'M’三种字符组成的字符串（可以只有其中一种或两种字符，但绝对不能有其他字符）且禁止出现 M 相邻的情况，问这样的串有多少种？</p></blockquote><p>考虑长度为 n，且以 ‘A’ 结尾的串有 f[n][0] 种、以 ‘C’ 结尾的串有 f[n][1] 种、以 ‘M’ 结尾的串有 f[n][2] 种，那么我们要求的答案就是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{2} f[n][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>如果第 n 个结尾的字符是 ‘A’ 或者 ‘C’，那么显然， 第 n−1 个字符可以是任意字符；而如果第 n 个结尾的字符是 ‘M’，那么第 n−1 个字符只能是是 ‘A’ 或者 ‘C’。所以可以得到递推公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][0] = f[n-1][0]+f[n-1][1]+f[n-1][2] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][1]=f[n-1][0]+f[n-1][1]+f[n-1][2] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][2]=f[n-1][0]+f[n-1][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p><p>到这一步，我们就可以利用程序求解了，但是，还可以化解，由于</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{2} f[n][i]=f[n][0]+f[n][1]+f[n][2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p>于是，可以得出：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][0]=\sum_{i=0}^{2} f[n-1][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][1]=\sum_{i=0}^{2} f[n-1][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][2]=\sum_{i=0}^{2} f[n-2][i]+\sum_{i=0}^{2} f[n-2][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>从而得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{2}f[n][i]= 2 \times (\sum_{i=0}^{2}f[n-1][i]+\sum_{i=0}^{2}f[n-2][i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p><p>令</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g[n]=\sum_{i=0}^{2}f[n][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>原式可以化解为如下递推式（升维再降维）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g[n]=2\times(g[n-1]+g[n-2])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">])</span></span></span></span></span></p><p>然后我们手动算出长度为 1 和 长度为 2 的串的方案数，递推代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">getACM</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> g[<span class="number">40</span>];</span><br><span class="line">    g[<span class="number">1</span>] = <span class="number">3</span>, g[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    g[i] = <span class="number">2</span> * (g[i<span class="number">-1</span>] + g[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="习题">习题</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/submissions/481025216/">70. 爬楼梯 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/three-steps-problem-lcci/submissions/481023120/">面试题 08.01. 三步问题 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/submissions/481035103/">1997. 访问完所有房间的第一天 - 力扣（LeetCode）</a></p><h4 id="访问完所有房间的第一天">访问完所有房间的第一天</h4><h5 id="思路分析">思路分析</h5><p>动态规划，dp[i]表示从0房间到第i个房间所需要的时间。</p><p>根据0&lt;=nextVisit[i]&lt;=i可以判定访问次数为基数时必回退到小于等于i的某个点，为偶数时才会 +1，故从dp[i+1]=dp[i]+(dp[i]-dp[nextVisit[i]])+2</p><p>公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>V</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[i]=2∗dp[i−1]−dp[nextVisit[i−1]]+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mord mathnormal">Vi</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></span></p><h5 id="代码">代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">firstDayBeenInAllRooms</span><span class="params">(<span class="type">int</span>* nextVisit, <span class="type">int</span> nextVisitSize)</span>&#123;</span><br><span class="line">    <span class="type">long</span>* dp = <span class="built_in">malloc</span>(nextVisitSize*<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mod = (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nextVisitSize;i++)&#123;</span><br><span class="line">        dp[i] = (<span class="number">2</span>*dp[i<span class="number">-1</span>]-dp[nextVisit[i<span class="number">-1</span>]]+<span class="number">2</span>+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)dp[nextVisitSize<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟</title>
      <link href="/2023/11/06/%E6%A8%A1%E6%8B%9F/"/>
      <url>/2023/11/06/%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1>模拟</h1><h2 id="前言">前言</h2><blockquote><p>模拟算法其实就是根据题目做，题目要求什么，就做什么。</p></blockquote><h2 id="一、数据结构">一、数据结构</h2><p>对于模拟题而言，最关键的其实是数据结构，看到一个问题，选择合适的数据结构，然后根据问题来实现对应的功能。模拟题的常见数据结构主要就是：数组、字符串、矩阵、链表 等等。</p><h3 id="1、基于数组">1、基于数组</h3><p>利用数组的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/build-array-from-permutation/">1920. 基于排列构建数组</a>、<a href="https://leetcode.cn/problems/create-target-array-in-the-given-order/">1389. 按既定顺序创建目标数组</a>、<a href="https://leetcode.cn/problems/design-parking-system/">1603. 设计停车系统</a>、<a href="https://leetcode.cn/problems/rearrange-array-elements-by-sign/">2149. 按符号重排数组</a>、<a href="https://leetcode.cn/problems/find-triangular-sum-of-an-array/">2221. 数组的三角和</a></p><h3 id="2、基于字符串">2、基于字符串</h3><p>利用字符串的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/">2011. 执行操作后的变量值</a>、<a href="https://leetcode.cn/problems/find-maximum-number-of-string-pairs/">2744. 最大字符串配对数目</a>、<a href="https://leetcode.cn/problems/nGK0Fy/">LCP 17. 速算机器人</a>、<a href="https://leetcode.cn/problems/complex-number-multiplication/">537. 复数乘法</a></p><h3 id="3、基于链表">3、基于链表</h3><p>利用链表的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/merge-nodes-in-between-zeros/">2181. 合并零之间的节点</a>、<a href="https://leetcode.cn/problems/find-the-winner-of-the-circular-game/">1823. 找出游戏的获胜者</a></p><h3 id="4、基于矩阵">4、基于矩阵</h3><p>利用矩阵的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/">2120. 执行所有后缀指令</a>、<a href="https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/">1252. 奇数值单元格的数目</a>、<a href="https://leetcode.cn/problems/flipping-an-image/">832. 翻转图像</a>、<a href="https://leetcode.cn/problems/robot-return-to-origin/">657. 机器人能否返回原点</a>、<a href="https://leetcode.cn/problems/game-of-life/">289. 生命游戏</a>、<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a>、<a href="https://leetcode.cn/problems/spiral-matrix-iii/">885. 螺旋矩阵 III</a></p><h3 id="5、基于栈">5、基于栈</h3><p>利用栈的数据结构，如：<a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/">1441. 用栈操作构建数组</a></p><h3 id="6、基于队列">6、基于队列</h3><p>利用队列的数据结构，如：<a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></p><h2 id="二、算法技巧">二、算法技巧</h2><p>模拟时一般会用到一些算法技巧，或者说混合算法，比如 排序、递归、迭代 等等。</p><h3 id="1、排序">1、排序</h3><p>排序后，干一件事情，如：<a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/">950. 按递增顺序显示卡牌</a></p><h3 id="2、递归">2、递归</h3><p>需要借助递归来实现，如：<a href="https://leetcode.cn/problems/count-of-matches-in-tournament/">1688. 比赛中的配对次数</a> 、<a href="https://leetcode.cn/problems/count-operations-to-obtain-zero/">2169. 得到 0 的操作数</a>、<a href="https://leetcode.cn/problems/add-digits/">258. 各位相加</a></p><h3 id="3、迭代">3、迭代</h3><p>不断迭代求解，其实就是利用 while 循环来实现功能，如：<a href="https://leetcode.cn/problems/incremental-memory-leak/">1860. 增长的内存泄露</a>、<a href="https://leetcode.cn/problems/add-digits/">258. 各位相加</a></p><h2 id="三、实例">三、实例</h2><ol><li><a href="https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/submissions/480232981/">1252. 奇数值单元格的数目 - 力扣（LeetCode）</a></li></ol><h4 id="题目">题目</h4><blockquote><p>给你一个 <code>m x n</code> 的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p><p>另有一个二维索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 指向矩阵中的某个位置，其中 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（<strong>从 <code>0</code> 开始编号</strong>）。</p><p>对 <code>indices[i]</code> 所指向的每个位置，应同时执行下述增量操作：</p><ol><li><code>ri</code> 行上的所有单元格，加 <code>1</code> 。</li><li><code>ci</code> 列上的所有单元格，加 <code>1</code> 。</li></ol><p>给你 <code>m</code>、<code>n</code> 和 <code>indices</code> 。请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 <strong>奇数值单元格</strong> 的数目。</p></blockquote><h4 id="思路">思路</h4><p>按要求进行操作即可。</p><h4 id="代码">代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">oddCells</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span>** indices, <span class="type">int</span> indicesSize, <span class="type">int</span>* indicesColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, r, c;</span><br><span class="line">    <span class="type">int</span> mat[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(mat));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; indicesSize; ++i) &#123;</span><br><span class="line">        r = indices[i][<span class="number">0</span>];</span><br><span class="line">        c = indices[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; m; ++j) &#123;</span><br><span class="line">            mat[j][c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            mat[r][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mat[i][j] &amp; <span class="number">1</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/complex-number-multiplication/solutions/1283204/fu-shu-cheng-fa-by-leetcode-solution-163i/">537. 复数乘法 - 力扣（LeetCode）</a></li></ol><h4 id="题目-2">题目</h4><blockquote><p><a href="https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0/254365?fr=aladdin">复数</a> 可以用字符串表示，遵循 <strong><code>&quot;实部+虚部i&quot;</code></strong> 的形式，并满足下述条件：</p><ul><li><code>实部</code> 是一个整数，取值范围是 <code>[-100, 100]</code></li><li><code>虚部</code> 也是一个整数，取值范围是 <code>[-100, 100]</code></li><li><code>i2 == -1</code></li></ul><p>给你两个字符串表示的复数 <code>num1</code> 和 <code>num2</code> ，请你遵循复数表示形式，返回表示它们乘积的字符串。</p></blockquote><h4 id="思路-2">思路</h4><p>由于直接从头到尾模拟将会耗费大量时间且毫无意义（实现读取实部和虚部的函数，实现字符串转数字的函数，还有他们的反函数等等），因此在这里采取格式化的措施。优点是简洁易读，缺点是效率不咋地。</p><h4 id="代码-2">代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">complexNumberMultiply</span><span class="params">(<span class="type">char</span>* num1, <span class="type">char</span>* num2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> real1, imag1, real2, imag2;</span><br><span class="line">    <span class="built_in">sscanf</span>(num1, <span class="string">&quot;%d+%di&quot;</span>, &amp;real1, &amp;imag1);</span><br><span class="line">    <span class="built_in">sscanf</span>(num2, <span class="string">&quot;%d+%di&quot;</span>, &amp;real2, &amp;imag2);</span><br><span class="line">    <span class="type">char</span> *ans = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(ans, <span class="string">&quot;%d+%di&quot;</span>, real1 * real2 - imag1 * imag2, real1 * imag2 + real2 * imag1);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2023/11/06/%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/11/06/%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1>枚举</h1><h2 id="定义">定义</h2><blockquote><p>枚举的概念就是把满足题目条件的所有情况都列举出来，然后一一判定，找到最优解的过程。</p></blockquote><h2 id="一、最值问题">一、最值问题</h2><p>比较经典的枚举问题莫过于最值问题了，也就是求一堆数中的最大值或者最小值。</p><h3 id="1、两个数的最值问题">1、两个数的最值问题</h3><p>两个数的最小值，利用C语言中的三元运算符就可以实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、n-个数的最值问题">2、n 个数的最值问题</h3><p>当有 n 个数时 ai 时，我们可以首先取前两个数，计算最小值；然后再拿这个最小值和第三个数去比较，得到的最小值再去和第四个数比较，以此类推，就可以计算出 n 个数中的最小值。</p><p>假设前 i 个数的最小值为 mi，则有递推公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>a</mi><mi>i</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}m_{i}=\left\{\begin{aligned}a_{i} &amp;&amp; i=0 \\min(m_{i-1}, a_{i}) &amp;&amp; i&gt;0 \\\end{aligned}\right.\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></p><p>所以，把这个递推公式翻译成C语言，代码是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NMin</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *m = (<span class="type">int</span> *) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize );</span><br><span class="line">    <span class="type">int</span> m[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    m[i] = Min(m[i<span class="number">-1</span>], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = m[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的 m[i] 和 m[i-1] 可以利用迭代，存储在一个变量中，用 C语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NMin</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    m = Min(m, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、最值问题的下标">3、最值问题的下标</h3><p>当然，有些时候，我们求的并不是一个最小的数，要是要求出这个数组中，最小的数的下标，那么可以直接记录下标，并且比较的时候直接通过下标去索引到值，然后进行比较，像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NMin</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> mIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( a[i] &lt; a[mIdx] ) &#123;</span><br><span class="line">        mIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以尝试做一下这道题，巩固一下概念：<a href="https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/description/">2656. K 个元素的最大和 - 力扣（LeetCode）</a></p><h2 id="二、最值问题的进阶">二、最值问题的进阶</h2><h3 id="1、第三大的数">1、第三大的数</h3><p>有时候，我们求最大的数不够，想要求次大的，甚至第三大的，比如 1 2 2 3 中第三大的是 1 （相同的数只计算一次）。</p><p>这样的问题，核心思路就是先把最大的求出来；然后忽略最大的数的情况下，再去求最大的；这时候就得到了次大的，再把次大的也忽略以后，再求最大的，自然就是第三大的了。</p><p>当然你也可以将数组排序过后选取第三大的数。那为什么要使用枚举呢？思考一下二者的时间复杂度的区别。</p><p><a href="https://leetcode.cn/problems/third-maximum-number/submissions/479969011/">414. 第三大的数 - 力扣（LeetCode）</a></p><h3 id="2、数组中两元素的最大乘积">2、数组中两元素的最大乘积</h3><p>要求找到数组中两个元素的最大乘积，数组元素一定是正数。那么我们知道最大的两个元素相乘一定是最大的，所以就是找最大的元素 和 次大的元素，但是这个问题和 第三大的数 略微有些不同，相同的数会被计算进去。</p><p>所以，我们找到最大的数以后，可以把它的下标忽略掉；然后再去找最大的数，这样找到的一定是两个可重复的最大元素和次大元素，将两者相乘即可。</p><p>当然也可以直接把数组按照递增排序，然后取最后两个元素相乘。但是与上面一样，比较排序的最优时间复杂度为 O(nlogn)，而找两次最大值的时间复杂度为 O(n)。</p><h2 id="三、降维思想">三、降维思想</h2><p><strong>慎入！因为我自己也没彻底搞明白……至少目前是这样</strong></p><p>一些统计类问题，第一个思路就是枚举所有情况（也就是多个 for 循环），然后再去考虑是不是能够把某些 for 循环的 O(n) 的时间复杂度降为 O(1)，这个就是降维的思想。来看这个经典问题：</p><p>这个问题能自己想出来，听说就达到了 ACM 区域赛铜牌的水平。</p><blockquote><p>给你一个长度为 n (n ≤ 4000) 下标从 0 开始的整数数组 nums ，它包含 1 到 n 的所有数字，请你返回上升四元组的数目。如果一个四元组 (i, j, k, l) 满足以下条件，我们称它是上升的：</p><p>1）0 &lt;= i &lt; j &lt; k &lt; l &lt; n 且</p><p>2）nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。</p></blockquote><h3 id="1、O-n-4">1、O(n^4)</h3><p>首先，最坏时间复杂度的算法，相信大家都能想出来，就是枚举 i、j、k、l 四个变量，然后判断 nums 四个数的关系，进行统计累加，这种情况下，最坏的时间复杂度为 O(n^4)，由于 n 为 4000。</p><p>也就是相当于 n = 16000000 的数据量下，用 O(n^2) 的算法去求解问题，所以必然超时。</p><h3 id="2、O-n-3">2、O(n^3)</h3><p>如果要用 O(n^3) 的算法求解，你会怎么去思考呢？如果有想法，可以写好以后附在评论区。</p><h3 id="3、O-n-2">3、O(n^2)</h3><p>是的，由于 n 的范围限制， 就算你想出了 O(n^3) 的算法，还是过不了这个问题，我们需要继续想 O(n^2) 的算法。</p><p>算法思路如下：</p><p>1、首先，我们枚举 j 和 k，然后对所有满足 nums[j] &gt; nums[k] 的下标对，执行下一步。</p><p>2、那么只要我们找到数组下标为 0 到 j-1 的数中，小于 nums[k] 的个数，记为 a（也就是所有满足条件的 i）； 找到数组下标为 k+1 到 n-1 的数中，大于 nums[j] 的个数，记为 b（也就是所有满足条件的）； 将 a * b 就是所有满足条件的 (i, l) 对，把所有的 （i, l） 数对累加，就是我们最后要求的答案了。</p><p>3、于是问题转变成了求 <strong>找到数组下标为 0 到 j-1 的数中，小于 nums[k] 的个数</strong> 和 <strong>找到数组下标为 k+1 到 n-1 的数中，大于 nums[j] 的个数；</strong></p><p>4、定义两个辅助数组 less[4001][4001] 和 bigger[4001][4001]，令 less[i][j] 表示前 i-1 个数中，小于 j 的数的个数；令 bigger[i][j] 表示 i 以后（不包括 i）的数中，大于 j 的数的个数。less 和 bigger 的含义类似，通过两个 for 循环 枚举求出 less 和 bigger。</p><p>5、最后，只要枚举 j 和 k，在满足 nums[j] &gt; nums[k] 的条件下，累加 less[j][ nums[k] * bigger[k][nums[j]] 的和，就是我们要求的解了。</p><p>看懂了吗？看懂了。那就把代码发在评论区吧~</p><p>（P.S. 哪天我搞明白了就发上去……）</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/2023/11/06/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/06/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>计数排序</h1><p><strong>1. 概念定义</strong></p><p><strong>计数排序</strong>（Counting sort）是一个非基于比较的稳定的线性时间的排序算法，</p><ol><li>非基于比较：之前学的排序都是通过比较数据的大小来实现有序的，比如希尔排序等，而计数排序不用比较数据的大小。</li></ol><p>计数排序的名字会让我们想到“计数法”，实际上计数排序的实现就是使用的计数法。（类似哈希表的思想）</p><p><strong>工作原理</strong>：使用一个额外的数组 cnt，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数，然后根据数组 cnt 来将 A 中的元素排到正确的位置。</p><p><strong>具体实现</strong>：创建一个足够大的数组 cnt，足够大的意思是 cnt 的下标范围可以包括所有的待排序数据值。然后遍历待排序数据，使用计数法统计每个数据的出现次数。最后遍历 cnt 数组，将每一个值（cnt[i]）不为 0 的下标（i）放入原数组 cnt[i] 次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">101</span>];  <span class="comment">//因为最大的数据是100，所以数组下标要开到 101，否则会出现数组越界问题</span></span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));  <span class="comment">//初始化哈希表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        cnt[ s[i] ]++;  <span class="comment">//将计数的表中对应值所在位置加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; ++i) &#123;  <span class="comment">//按顺序取出哈希表中的值</span></span><br><span class="line">        <span class="keyword">while</span>(cnt[i]) &#123;</span><br><span class="line">            s[sSize++] = i;  <span class="comment">//请自行复习++i和i++的区别</span></span><br><span class="line">            cnt[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-题目练习"><strong>2. 题目练习</strong></h2><ol><li><a href="https://leetcode.cn/problems/neither-minimum-nor-maximum/description/">2733. 既不是最小值也不是最大值 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/find-the-difference/description/">389. 找不同 - 力扣（LeetCode）</a></li></ol><h2 id="3-解题报告"><strong>3. 解题报告</strong></h2><p><a href="https://leetcode.cn/problems/neither-minimum-nor-maximum/description/">2733. 既不是最小值也不是最大值 - 力扣（LeetCode）</a></p><p><strong>题目描述</strong></p><blockquote><p>给你一个整数数组 <code>nums</code> ，数组由 <strong>不同正整数</strong> 组成，请你找出并返回数组中 <strong>任一</strong> 既不是 <strong>最小值</strong> 也不是 <strong>最大值</strong> 的数字，如果不存在这样的数字，返回 <strong><code>-1</code></strong> 。</p><p>返回所选整数。</p></blockquote><ol><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>nums</code> 中的所有数字互不相同</li></ol><p><strong>解题思路</strong></p><p>将原数组排序，判断数组中的数是否与头尾元素相同，否则输出。</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        cnt[ s[i] ]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt[i]) &#123;</span><br><span class="line">            s[sSize++] = i;</span><br><span class="line">            cnt[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findNonMinOrMax</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    countingSort(nums, numsSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[numsSize<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="keyword">return</span> nums[i]; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-difference/description/">389. 找不同 - 力扣（LeetCode）</a></p><p><strong>题目描述</strong></p><blockquote><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，它们只包含小写字母。</p><p>字符串 <code>t</code> 由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <code>t</code> 中被添加的字母。</p></blockquote><ol><li><code>0 &lt;= s.length &lt;= 1000</code></li><li><code>t.length == s.length + 1</code></li><li><code>s</code> 和 <code>t</code> 只包含小写字母</li></ol><p><strong>解题思路</strong></p><p>将字符串排序，逐个比较至两者相同位置的元素不相同，输出t中该元素。</p><p>因为是字符串，排序函数需要做一些改动，按字符编码排序，并且别忘了在末尾加上终止符。</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; s[i]; ++i) &#123;</span><br><span class="line">        cnt[ s[i] ]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt[i]) &#123;</span><br><span class="line">            s[sSize++] = i;</span><br><span class="line">            cnt[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[sSize] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    countingSort(s);</span><br><span class="line">    countingSort(t);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; s[i]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != t[i]) <span class="keyword">return</span> t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目拓展</strong></p><ol><li>既然能使用计数排序，为什么不直接比较计数情况（通过哈希表）？如何实现？</li><li>既然是增加一个字符，那合并两个字符串后应该会出现有一个字母的数量是奇数。如何利用这一点改进程序？或者是采取一种新方法？（提示：位运算）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Counting Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建教程</title>
      <link href="/2023/11/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2023/11/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>博客搭建教程</h1><h2 id="前言">前言</h2><p>近些年来很多用户都喜欢使用 GitHub Pages 来搭建 Hexo 静态博客网站，其最吸引人的莫过于完全免费使用，并且非常稳定。</p><p>虽然搭建时比较麻烦，有点折腾，但是配置完成后，基本不需要操心维护的事，甚至放了几年都忘记了，打开来看文章依然还在。</p><p>本文就详细介绍下如何使用 Hexo + GitHub 搭建免费个人博客网站的教程。</p><h2 id="简介">简介</h2><h3 id="GitHub-Pages-是什么？">GitHub Pages 是什么？</h3><ul><li><a href="https://help.github.com/en/articles/what-is-github-pages">What is GitHub Pages? - GitHub Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h3 id="Hexo-是什么">Hexo 是什么?</h3><ul><li>官网：<a href="https://hexo.io/zh-cn/">hexo.io</a></li></ul><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p><h3 id="Hexo-GitHub-文章发布原理">Hexo + GitHub 文章发布原理</h3><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><img src="../img/Hexo + GitHub 文章发布原理.png" alt="picture" style="zoom: 33%;" /><h3 id="优点和不足">优点和不足</h3><p>**优点：**完全免费；静态站点，轻量快速；可按需求自由定制改造；托管在 GitHub，安全省心；迁移方便……</p><p>**不足：**发文不便，依赖于本地环境；更适合个人博客使用；GitHub 在国内访问速度有点不快。</p><h2 id="1-准备">1. 准备</h2><h3 id="注意事项">注意事项</h3><ul><li>输入代码时，核对准确，最好切换成英文输入法；</li><li>将文中的 “用户名” 和 “邮箱” 替换为自己的 GitHub 账户名和绑定的邮箱；</li><li>统一使用 Git Bash 进行操作；</li></ul><h3 id="环境搭建">环境搭建</h3><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。</p><ul><li>Node.js：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li><li>Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li></ul><p>下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。</p><p>安装完成后，Win+R 输入 cmd 并打开，依次输入 <code>node -v</code>、<code>npm -v</code> 和 <code>git --version</code> 并回车，如下图出现程序版本号即可。</p><img src="../img/屏幕截图1png.png" alt="picture" style="zoom:50%;" /><h2 id="2-连接-Github">2. 连接 Github</h2><p>使用邮箱注册 <a href="https://github.com/">GitHub</a> 账户，选择免费账户（Free），并完成邮件验证。</p><p>桌面按住shift右键 -&gt; Git Bash Here，<strong>设置用户名和邮箱</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>创建 SSH 密匙</strong>：</p><p>输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p><p><strong>添加密匙：</strong></p><p>进入 [C:\Users\用户名\.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p><p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p><p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p><img src="../img/屏幕截图 2023-11-04 220045.png" alt="picture" style="zoom:67%;" /><p><strong>验证连接：</strong></p><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。</p><img src="../img/屏幕截图 2023-11-04 212102.png" alt="picture" style="zoom: 67%;" /><p>显示 “Hi xxx! You’ve successfully……” 即连接成功。</p><h2 id="3-创建-Github-Pages-仓库">3. 创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>填好后点击 Create repository 创建。</p><img src="../img/屏幕截图 2023-11-04 212129.png" alt="picture" style="zoom:50%;" /><p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><h2 id="4-本地安装-Hexo-博客程序">4. 本地安装 Hexo 博客程序</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。</p><h3 id="安装-Hexo">安装 Hexo</h3><p>使用 npm 一键安装 Hexo 博客程序：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装时间有点久（想要加快可以试试魔法），界面也没任何反应，<strong>耐心等待</strong>，安装完成后如下图。</p><img src="../img/屏幕截图 2023-11-04 212141.png" alt="picture" style="zoom:67%;" /><h3 id="4-2-Hexo-初始化和本地预览">4.2 Hexo 初始化和本地预览</h3><p>新建一个文件夹作为你博客的仓库。你后面的工作将大部分在这个文件夹中完成。</p><p><strong>初始化并安装所需组件：</strong></p><p>在文件夹中按住shift右键，选择Git Bash Here（注意，以后的Git Bash最好也都这么启动）。输入下面的指令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init      # 初始化</span><br><span class="line">npm install    # 安装组件</span><br></pre></td></tr></table></figure><p>完成后依次输入下面命令，<strong>启动本地服务器进行预览</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo s   # 启动预览</span><br></pre></td></tr></table></figure><p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p><img src="../img/屏幕截图 2023-11-04 212154.png" alt="picture" style="zoom:67%;" /><p>**Tips：**如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo server -p 5000</code> 更改端口号后重试。</p><p>Hexo 博客文件夹目录结构如下：</p><img src="../img/屏幕截图 2023-11-04 212225.png" alt="picture" style="zoom: 67%;" /><h2 id="5-部署-Hexo-到-GitHub-Pages">5. 部署 Hexo 到 GitHub Pages</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先<strong>安装 hexo-deployer-git</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后<strong>修改 _config.yml</strong> 文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h2 id="6-开始使用">6. 开始使用</h2><h3 id="7-1-发布文章">7.1 发布文章</h3><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>然后 source 文件夹中会出现一个 <a href="http://My-New-Post.md">My-New-Post.md</a> 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p><p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这两条命令。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo d   # 部署发布</span><br></pre></td></tr></table></figure><hr><p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo g</code> 和 <code>hexo d</code> 发布。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">  - Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">  - PS3</span><br><span class="line">  - Games</span><br><span class="line">---</span><br><span class="line">&quot;Your article here&quot;</span><br></pre></td></tr></table></figure><h3 id="7-2-网站设置">7.2 网站设置</h3><p>包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a>按需要编辑。</p><p>注意：冒号后要加一个空格！</p><h3 id="7-3-更换主题">7.3 更换主题</h3><p>Hexo提供了非常多好看的主题（是的，经过美化后能够达各种效果），其中应用较为广泛的是Butterfly。关于更换主题和美化页面的教程，后面可能会单独写一篇文章。要是太着急的话，可以访问Hexo的官网寻找（他甚至还有简中，他真的，我哭死）。记住，最靠谱的永远是官方的手册！（RTFM, bro!）</p><h3 id="7-4-常用命令">7.4 常用命令</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure><h2 id="8-常见问题">8 常见问题</h2><p><strong>1、修改并部署后没有效果</strong></p><p>使用 <code>hexo clean</code> 清理后重新部署。</p><p><strong>2、开启 HTTPS 后访问网站显示连接不安全？</strong></p><p>证书还未部署生效，等待一会儿，清除浏览器缓存再试。</p><p><strong>3、npm 下载速度慢，甚至完全没反应</strong></p><p>使用 npm 安装程序等待很久也没反应，或者下载速度很慢，可以更换 npm 源为国内 npm 镜像。</p><p>临时更换方法：在 npm 安装命令后面加上：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--registry https://registry.npm.taobao.org </span><br></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>Hexo 是一种纯静态的博客，我们必须要在本地完成文章的编辑再部署到 GitHub 上，依赖于本地环境。不能像 WordPress 或 Typecho 那样的动态博客一样能直接在浏览器中完成撰文和发布。</p><p>可以说是一种比较极客的写博客方式，但是优势也是明显的——免费稳定省心，比较适合爱折腾研究的用户，或者没有在线发文需求的朋友。</p><p>如果在自己部署的过程中出现了问题，可以在下方留言，或者阅读官方的手册（更推荐！）。心动不如行动，赶快行动起来吧！</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Course </tag>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2023/11/04/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/04/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>冒泡排序</h1><p><strong>1. 概念定义</strong></p><p><strong>冒泡排序</strong>（<strong>Bubble Sort</strong>）又称为<strong>泡式排序</strong>，是一种简单的排序算法。</p><p><strong>核心思想</strong>：它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就像水中的气泡会冒起来一样。</p><p><strong>运作步骤</strong>（升序排列）：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>比如：</p><p>原始数据：3 2 7 8 6，将其按升序排列。</p><p>第一次循环：（最大的跑到最右边）</p><p>3 2 7 8 6 --&gt; 2 3 7 8 6 （3和2比较，3 &lt; 2，所以3和2交换位置）</p><p>2 3 7 8 6 --&gt; 2 3 7 8 6 （3和7比较。3 &lt; 7，所以3和7不用交换位置）</p><p>2 3 7 8 6 --&gt; 2 3 7 8 6 （7和8比较，7 &lt; 8，所以7和8不用交换位置）</p><p>2 3 7 8 6 --&gt; 2 3 7 6 8 （8和6比较，8 &gt; 6，所以8和6交换位置）</p><p>经过第1次循环，此时剩下参与比较的数据：2 3 7 6</p><p>第二次循环：</p><p>2 3 7 6 --&gt; 2 3 7 6 （2和3比较，不需要交换位置）</p><p>2 3 7 6 --&gt; 2 3 7 6 （3和7比较，不需要交换位置）</p><p>2 3 7 6 --&gt; 2 3 6 7 （7和6比较，7 &gt; 6，所以7和6交换位置）</p><p>经过第2次循环，此时剩下参与比较的数据：2 3 6</p><p>第三次循环：</p><p>2 3 6 （2和3比较，不需要交换位置）</p><p>2 3 6 （3和6比较，不需要交换位置）</p><p>经过第3次循环，此时剩下参与比较的数据：2 3</p><p>第四次循环：</p><p>2 3 （2和3比较，不需要交换位置）</p><p>至此，5个数经历了4次循环，每次循环都将当前最大的书交换的最右的位置，然后下次循环就不再考虑该数。</p><p><strong>具体实现</strong>：使用双重循环，外层循环控制循环的次数，内层循环进行数字的比较。内层每一次循环结束之后，都要找出最大的数据，放到参与比较的这堆数据的最右边，下次循环不再比较该数。</p><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i) &#123;  <span class="comment">//因为每次比较两个数，所以总共n个数，只需要比较n-1次（外循环n-1次）</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; ++j) &#123;  <span class="comment">//每次比较完后，最大的值在下一次比较中不用比较，所以每次比较只需要循环n-1-i 次（内循环n-1-i次）</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-题目练习"><strong>2. 题目练习</strong></h2><ol><li><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></li><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></li><li><a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/">至少是其他数字两倍的最大数</a></li></ol><h2 id="3-解题报告"><strong>3. 解题报告</strong></h2><p><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></p><p><strong>题目描述</strong></p><blockquote><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p></blockquote><p><strong>解题思路</strong></p><p>使用冒泡排序将数组按升序排列，排完序后相同的数就会相邻。</p><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i) &#123;  <span class="comment">//因为每次比较两个数，所以总共n个数，只需要比较n-1次（外循环n-1次）</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; ++j) &#123;  <span class="comment">//每次比较完后，最大的值在下一次比较中不用比较，所以每次比较只需要循环n-1-i 次（内循环n-1-i次）</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    bubbleSort(nums, numsSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="剩下的题目大同小异，在此不多做展示。">剩下的题目大同小异，在此不多做展示。</h5>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Bubble Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2023/11/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>插入排序</h1><h3 id="1-概念定义"><strong>1. 概念定义</strong></h3><p><strong>插入排序</strong>（Insertion Sort），一般也被称为直接插入排序，是一种简单直观的排序算法。</p><p><strong>工作原理</strong>：将待排列元素划分为「已排序」和「未排序」两部分，每次从「未排序的」元素中选择一个插入到「已排序的」元素中的正确位置。</p><p>这个过程类似于平时打扑克牌时摸牌的操作：右手摸牌，根据牌面大小，放到左手中正确的位置。</p><p><a href="https://gitee.com/LowProfile666/image-bed/raw/master/img/insertion-sort-1-animate-example.svg">这里有张动图，但是好像放不上来</a></p><p>比如：1 2 6 3 4 7 5 ，将其从小到大排序。</p><p>第一次参与排序的数据：2 6 3 4 7 5（因为最开始没有[已排序的]，所以第一个数可以直接作为[已排序的]）</p><p>第一次循环：</p><p>当前的数：2</p><p>当前已有序列表：1</p><p>2 &gt; 1 : 2 放在 1 之后</p><p>第二次参与排序的数据：6 3 4 7 5</p><p>第二次循环：</p><p>当前的数：6</p><p>当前已有序列表：1 2</p><p>6 &gt; 2 : 6 放在 2 之后</p><p>第三次参与排序的数据：3 4 7 5</p><p>第三次循环：</p><p>当前的数：3</p><p>当前已有序列表：1 2 6</p><p>3 &lt; 6 :</p><p>3 &gt; 2 : 3 放在 2 之后</p><p>第四次参与排序的数据：4 7 5</p><p>第四次循环：</p><p>当前的数：4</p><p>当前已有序列表：1 2 3 6</p><p>4 &lt; 6 :</p><p>4 &gt; 3 : 4 放在 3 之后</p><p>第五次参与排序的数据：7 5</p><p>第五次循环：</p><p>当前的数：7</p><p>当前已有序列表：1 2 3 4 6</p><p>7 &gt; 6 : 7 放在 6 之后</p><p>第六次参与排序的数据：5</p><p>第六次循环：</p><p>当前的数：5</p><p>当前已有序列表：1 2 3 4 6 7</p><p>5 &lt; 7 :</p><p>5 &lt; 6 :</p><p>5 &gt; 4 : 5 放在 4 之后</p><p>至此，数据全部排序为：1 2 3 4 5 6 7</p><p><strong>具体实现</strong>：使用双层循环，外层循环枚举除了第一个元素之外的所有元素，内层循环遍历当前元素前面的有序表，进行待插入位置查找，并进行移动。时间复杂度为O(n^2^)，空间复杂度为O(1)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> *number, <span class="type">int</span> n)</span>    <span class="comment">//定义一个插入函数&quot;insertionSort&quot; </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">//循环遍历 </span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = number[i];  <span class="comment">//将tmp每一次赋值为number[i]  </span></span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)  <span class="comment">//比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; number[j]) number[j+<span class="number">1</span>] = number[j];  <span class="comment">//更小交换</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        number[j+<span class="number">1</span>] = tmp;   <span class="comment">//否则添加到最后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题目练习"><strong>2. 题目练习</strong></h3><ol><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组（基础题）</a></li><li><a href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序（提高题）</a></li></ol><h3 id="3-解题报告"><strong>3. 解题报告</strong></h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a></p><p><strong>题目描述</strong></p><blockquote><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p></blockquote><p><strong>解题思路</strong></p><p>先将 nums2 的元素放到 nums1 里去，然后对整个 nums1 数组进行插入排序。</p><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> *number, <span class="type">int</span> n)</span>    <span class="comment">//定义一个插入函数&quot;insertionSort&quot; </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">//循环遍历 </span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = number[i];  <span class="comment">//将tmp每一次赋值为number[i]  </span></span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)  <span class="comment">//比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; number[j]) number[j+<span class="number">1</span>] = number[j];  <span class="comment">//更小交换</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        number[j+<span class="number">1</span>] = tmp;   <span class="comment">//否则添加到最后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span> m, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i,j= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = m; i &lt; m+n; i++)  <span class="comment">//合并数组</span></span><br><span class="line">    &#123;  </span><br><span class="line">        nums1[i] = nums2[j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = m + n;</span><br><span class="line">    insertionSort(nums1, size);  <span class="comment">//排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序</a></p><p><strong>题目描述</strong></p><blockquote><p>给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。</p></blockquote><p><strong>解题思路</strong></p><p>利用直接插入排序的算法思想，单链表无法向前遍历，需要通过三个指针完成操作。</p><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">insertionSortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)                                                        <span class="comment">//链表为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">L</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode)); <span class="comment">//辅助结点</span></span><br><span class="line">    L-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head-&gt;next, *pre = head, *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;                                                     <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val &gt;= pre-&gt;val)&#123;                                           <span class="comment">//寻找需要向前插入的结点</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp = L;</span><br><span class="line">            <span class="keyword">while</span>(tmp-&gt;next-&gt;val &lt; cur-&gt;val)                                <span class="comment">//寻找插入位置</span></span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;                                          <span class="comment">//进行插入</span></span><br><span class="line">            cur-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = cur;</span><br><span class="line">            cur = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Insertion Sort </tag>
            
            <tag> Link List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2023/11/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>选择排序</h1><p>直观且简单的一种排序，将未排序的头个元素与后面的比较，选择最小的放到最前。时间复杂度为O(n^2^)，空间复杂度为O(1)。</p><p>例如：[4, 7, 2, 5]   ——&gt; 将4与后面的7, 2, 5比较——&gt; 把最小的2与4的位置调换 ——&gt; 将第二位的7与后面的数字比较 ——&gt; 将7与后面数字中最小的4调换 …… 以此类推。</p><h5 id="代码实现：">代码实现：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void selectionSort(int* nums, int numsSize) &#123;</span><br><span class="line">    int i, j, min;</span><br><span class="line">    for(i = 0; i &lt; numsSize - 1; ++i) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        for(j = i + 1; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            if(nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp = nums[min];</span><br><span class="line">        nums[min] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="题目链接：">题目链接：</h5><p><a href="https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/">判断能否形成等差数列</a></p><p><a href="https://leetcode.cn/problems/largest-number-at-least-twice-of-others/">至少是其他数字两倍的最大数</a></p><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></p><p><a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></p><h5 id="题解：">题解：</h5><p>4道题目均可以采用调用排序函数后对排序过的数组进行操作得出答案，由于较为简单，因此就不放题解了~</p><p>（绝对不是因为偷懒，绝对不是！）</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Selection Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome! This is my first blog.</title>
      <link href="/2023/11/02/Welcome-This-is-my-first-blog/"/>
      <url>/2023/11/02/Welcome-This-is-my-first-blog/</url>
      
        <content type="html"><![CDATA[<h1>Welcome!</h1><p>Welcome to my blog!</p><p>I will post some articles here. They might be useful, but I think most of them will be useless but funny. My native language is Chinese, so most of the articles will be written in Chinese. But I may translate some of them into English in order to improve my ability.</p><p>Thank you for spending time reading. See you again!</p>]]></content>
      
      
      <categories>
          
          <category> English Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Start </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到我的博客！</title>
      <link href="/2023/11/02/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81/"/>
      <url>/2023/11/02/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1>欢迎！</h1><p>我希望在这里分享一些有用或者有趣的东西。</p><p>作为一名技术小白，我希望有一个地方能够记录我的成长，并且同时能够帮助一些有需要的人。所以想到了搭建一个属于我自己的博客。在查阅了众多资料、解决了各种困难后，这个网站终于初现雏形。虽然他现在还很简陋，但是我相信随着我的进步，他一定会更加完善，最后变成一个优雅的个人博客。我很期待那一天的到来。</p><p>也欢迎大家访问、留言（后面会开放的……吧），希望能与小白共同成长，让大犇驻足相助~</p><h6 id="博客0-0测试版（因为当时没有截图所以找了一张相近的顶一下）">博客0.0测试版（因为当时没有截图所以找了一张相近的顶一下）</h6><p><img src="https://s2.loli.net/2023/11/02/3apnkItSCyvBVQD.jpg" alt="屏幕截图 2023-11-02 172526.jpg"></p><h6 id="博客1-0测试版">博客1.0测试版</h6><p><img src="https://s2.loli.net/2023/11/02/m7IPrzYM9tB6yFl.jpg" alt="屏幕截图 2023-11-02 172200.jpg"></p><h6 id="博客1-1发布版">博客1.1发布版</h6><p><img src="https://s2.loli.net/2023/11/02/yxGDq8OVnbvKjc3.png" alt="屏幕截图 2023-11-02 180941.png"></p>]]></content>
      
      
      <categories>
          
          <category> 岁月史书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Start </tag>
            
            <tag> History </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/01/hello-world/"/>
      <url>/2023/11/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to a website created with <a href="https://hexo.io/">Hexo</a>! This is the very first post. To memorialize it, I named him “Hello World”.</p><p>Check <a href="https://hexo.io/docs/">documentation</a> for more info. If  get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="PS">PS:</h2><p>As you can see, this article is mostly created by Hoxe, a useful tool to build a blog. I keep this page not only   to show my gratitude, but also to help me when I forget how to use it. If you also want to set up a personal blog, you can try it! And remember, the official manual is always the best choice when you want to learn something.</p>]]></content>
      
      
      <categories>
          
          <category> English Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Start </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
