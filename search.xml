<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>surface改造——安装Ubuntu</title>
      <link href="/2025/01/18/surface%E6%94%B9%E9%80%A0%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Ubuntu/"/>
      <url>/2025/01/18/surface%E6%94%B9%E9%80%A0%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Ubuntu/</url>
      
        <content type="html"><![CDATA[<h1>surface改造——安装Ubuntu</h1><p>事情的起因是觉得每次都带游戏本去上课太重了，想找个轻一点的趁手工具。本着能省就省和可玩性高的原则，最后在海鲜市场淘了一台二（？）手的<code>surface pro 4</code>（带个问号是因为机身上贴有转转的验机贴，疑似不止二手，but who cares?）。作为一台发布于2015年的win平板，虽然它重量不轻，屏占比不高，处理器不好，电池续航4小时，发热严重，但是它只要550（8+256），还能玩gal。不过最重要的是，搭载了x86架构处理器，在折腾的方便程度上明显好于arm架构。没有谁能拒绝把一个电子产品安装上Linux系统，没有。</p><p>~~考虑到之后还想玩gal，~~这次的改造选择了安装双系统，对原win10进行了保留。</p><blockquote><p><strong>What You Need</strong></p><ul><li>Surface(any type <strong><a href="https://github.com/linux-surface/linux-surface/wiki/Supported-Devices-and-Features#feature-matrix">supported by linux-surface</a></strong>)</li><li>U disk</li><li>Keyboard</li><li>Love and Peace</li></ul></blockquote><h2 id="准备工作">准备工作</h2><h3 id="镜像（iso">镜像（iso)</h3><p>任意**<a href="https://github.com/linux-surface/linux-surface">linux-surface</a>**支持的Linux系统镜像都是可以的。当然如果不介意某些硬件（比如触屏）无法正常工作或者热衷于手搓客制化内核的话，其他系统也是可以的。</p><p>只推荐直接前往官网下载。镜像站也不是不行，但总不如官网直接。</p><p>本人使用的是<code>Ubuntu LTS 24.04</code>，顺手贴个官网，似乎能直连，不知道下载速度怎么样。<a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a></p><h3 id="启动盘">启动盘</h3><p>把下载完的镜像写入准备好的U盘，以在其他设备上安装系统。</p><p>工具有很多，比如<strong>Rufus</strong>、<strong>UltraISO</strong>等等。界面基本都很直观，也有很多教程，不在这里赘述了。</p><p><s>其实就是懒狗，当时没有留图片，懒得再去搞了</s></p><h3 id="分配设备空间">分配设备空间</h3><p>在surface上分配好给两个系统各自的空间。当然如果不想装双系统，那可以跳过这一步，直接覆盖安装就好。</p><ol><li><p>鼠标右键<strong>开始</strong>图标（也就是底下的<strong>Windows</strong>图标），点击<strong>磁盘管理</strong>。（话说我刚刚发现这里能直接打开powershell管理员）</p></li><li><p>在进入下方页面后，选择你想安装的磁盘（这张图里就一个磁盘），右键想安装的分区（这张图里就一个分区能安装），选择压缩卷，输入你想分配的空间大小（即压缩空间量），建议不低于50GB。</p><p><img src="../../../../img/surface/708ae5bd044c68c2bdda6509b8da624.jpg" alt="708ae5bd044c68c2bdda6509b8da624"></p></li><li><p>压缩完成后可以得到一个未分配空间，至此完成空间分配。</p></li></ol><p><s>实在不懂的找一下磁盘分区教程，一样的，反正最后拿来装系统的分区都会格式化，有没有分配空间都无所谓了</s></p><h2 id="安装系统">安装系统</h2><h3 id="UEFI设置">UEFI设置</h3><p>UEFI是surface的一个类似bios的界面，你需要在这里完成一些更改以完成后续安装。</p><ol><li><p>选择<strong>重启电脑</strong>，等待关机后，长按<strong>开机键</strong>和<strong>音量加键</strong>，等待电脑进入UEFI界面，如下图。</p><p><img src="../../../../img/surface/95e21b08e5af24caff52d06fe4e8afa8.jpg" alt="95e21b08e5af24caff52d06fe4e8afa8"></p></li><li><p>选择<strong>security</strong>，可以看到<strong>Secure boot</strong>，点击下方的<strong>change configuration</strong>，在展开项中选择<strong>none</strong>，然后<strong>OK</strong>。<strong>Secure boot</strong>是surface自带的一个安全启动项，可以自行查询其作用。但是在双系统的安装过程中，它只是一个烦人的障碍，所以我们直接关掉就好。</p><p><img src="../../../../img/surface/fd795ed3f18b6697e9ea20ad8825a777.jpg" alt="fd795ed3f18b6697e9ea20ad8825a777"></p></li><li><p>点击<strong>boot configuration</strong>，可以看到第一个是Windows的启动项，用手将<strong>USB configuration</strong>拖到第一项，即设置从U盘启动为最优先，以在后续进入启动盘。</p><p><img src="../../../../img/surface/35ea65d4e83ec3a865e092b54b04e6cc.jpg" alt="35ea65d4e83ec3a865e092b54b04e6cc"></p></li><li><p>完成后点击exit，点击restart即可</p><p><img src="../../../../img/surface/d123d2c5f7034c6f52a81bcfcb35b213.jpg" alt="d123d2c5f7034c6f52a81bcfcb35b213"></p></li></ol><h3 id="初步安装">初步安装</h3><p>Surface上Linux的安装与其他设备并无二异，此处简要介绍，也可以参考其他更详细的教程。而之所以称为初步，是因为对比其他设备，surface在安装完成后需要对系统内核进行更换，否则可能出现硬件适配问题，故正常系统安装只是初步完成任务。</p><ol><li><p>插入U盘，启动surface，选择进入系统安装界面。</p><p><img src="../../../../img/surface/7938c2252af5849f5beaf76a16f46fd.jpg" alt="7938c2252af5849f5beaf76a16f46fd"></p></li><li><p>进入安装界面后，选择<strong>手动分区（图中最后一项）</strong>。</p><p><img src="../../../../img/surface/de9e0deb4f9624721680ca7130e5096.jpg" alt="de9e0deb4f9624721680ca7130e5096"></p><blockquote><p>这里作者尝试过第一个选项（即目前图中选择的这项），但是出现了下图的问题。由于懒得再去折腾，所以选择了手动分区。有感兴趣的可以自行尝试这个选项，也欢迎交流相关经验。</p><p><img src="../../../../img/surface/7429b789a5a4a0caf55496d1d66c819.jpg" alt="7429b789a5a4a0caf55496d1d66c819"></p></blockquote></li><li><p>进入<strong>手动分区</strong>后，选择一个磁盘作为安装引导程序的设备（一般只有一个磁盘，除非你加盘了），再选择之前在分配设备空间时分配出的未分配卷安装系统（可以根据卷的容量大小辨别）。</p><p>注意，下面第一张图没有选择引导程序设备（左下角），所以无法选择安装系统。</p><p><img src="../../../../img/surface/1ea865a9de36c375a3b2dbe8d47c639.jpg" alt="1ea865a9de36c375a3b2dbe8d47c639"></p><p><img src="../../../../img/surface/52b01e9ebcbb53e572a36b9693a1a27.jpg" alt="52b01e9ebcbb53e572a36b9693a1a27"></p><blockquote><p>Ubuntu中安装引导程序的设备的作用是引导设备启动Ubuntu系统，如果你想尝试使用其他设备（如光盘、U盘等）启动系统，也可以进行相关尝试。当然也因为这个程序的存在，系统理论上可以安装在其他地方。听起来不错，有时间可以继续折腾下…</p></blockquote></li><li><p>后续按照说明进行即可。当然如果你没有网络连接，需要跳过Ubuntu Pro。</p><p><img src="../../../../img/surface/f227a34fb75a10fb4e4a7c6050e3624.jpg" alt="f227a34fb75a10fb4e4a7c6050e3624"></p></li><li><p>完成安装后，拔掉U盘，重启电脑，成功进入Ubuntu系统，则系统安装初步成功。</p><p><img src="../../../../img/surface/5f85dcd1ad7e0b9d51892c12a86376b.jpg" alt="5f85dcd1ad7e0b9d51892c12a86376b"></p><p><img src="../../../../img/surface/fbfd9f12fcdd54594afc8531a177f58.jpg" alt="fbfd9f12fcdd54594afc8531a177f58"></p></li></ol><h3 id="更换内核">更换内核</h3><p>Ubuntu自带的驱动不能兼容Surface的硬件，所以很多硬件无法使用，比如键盘，触屏等。好在世界上总不缺乏喜欢折腾的人，感谢各位contributors的不断更新与维护，让我们的折腾更加丝滑♥</p><h6 id="代码仓库">代码仓库</h6><p><a href="https://github.com/linux-surface/linux-surface">linux-surface/linux-surface: Linux Kernel for Surface Devices</a></p><h6 id="Wiki-Page">Wiki Page</h6><p><a href="https://github.com/linux-surface/linux-surface/wiki">Home · linux-surface/linux-surface Wiki</a></p><h6 id="安装方法">安装方法</h6><p><a href="https://github.com/linux-surface/linux-surface/wiki/Installation-and-Setup">Installation and Setup · linux-surface/linux-surface Wiki</a></p><p>还有更多的折腾内容比如签名内核之类的东西基本都在里面能找到，有什么问题也可以提issue。</p><p>最后别忘了给仓库一颗star~</p><h2 id="完成改造">完成改造</h2><p>至此，Ubuntu已经完美的安装到你的Surface设备上了，后续工作，比如换源、美化等等，可以参考其他资料~~，我继续摸鱼去了~~。</p><h4 id="日后谈">日后谈</h4><p>在后续使用的过程中遇到一些问题，在这里补充（吐槽）…</p><ol><li>更换内核后可能会出现一些小问题（触屏突然失灵之类的），所以要时不时更新（会自动提醒的，至少Ubuntu会）。但是如果更新太勤快有时候也会变成第一批体验各种bug的先锋，严重的bug会让系统无法使用。所以更新前最好先看看有没有人提这个版本的bug issue…</li><li>当时24.04刚刚发布，各种适配还没做好，试错的过程非常坐牢，喜欢尝新是有代价的，所以图方便的话用稳定的发行版自然是最好的…</li></ol>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Surface </tag>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配</title>
      <link href="/2024/06/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>/2024/06/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1>字符串匹配</h1><blockquote><p>This article is a study note on Introduction to Algorithms.</p></blockquote><h2 id="定义">定义</h2><p>顾名思义，在一个<strong>目标串</strong>中寻找是否出现<strong>模板串</strong>的过程，为字符串匹配。</p><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">预处理时间</th><th style="text-align:center">匹配时间</th></tr></thead><tbody><tr><td style="text-align:center">朴素算法</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ο((n-m+1)m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">O</span><span class="mopen">((</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center">Rabin-Karp</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ο((n-m+1)m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">O</span><span class="mopen">((</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center">有限自动机算法</td><td style="text-align:center">$Ο(m</td><td style="text-align:center">\Sigma</td></tr><tr><td style="text-align:center">Knuth-Morris-Pratt</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><h2 id="朴素字符串匹配算法">朴素字符串匹配算法</h2><p>最简单直观的算法，又叫做<code>BF(Brute Force)算法</code>。两层循环，逐一比较目标串与模式串之间的每一个字符是否匹配。</p><h6 id="伪代码">伪代码</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAIVE-STRING-MATCHER(T,P) </span><br><span class="line">n = T.length </span><br><span class="line">m = P.length </span><br><span class="line">for s = O to n — m </span><br><span class="line">if P[1..m] == T[s+1.. s+m]</span><br><span class="line"> print &quot;Pattern occurs with shift&quot; s</span><br></pre></td></tr></table></figure><h6 id="时间复杂度">时间复杂度</h6><p>在最坏情况下，朴素字符串匹配算法运行时间为O((n-m+l)m)。例如，在考察文本字符串 a^n^（一串由<code>n</code>个<code>a</code>组成的字符串）和模式 a^m^ 时，对偏移<code>s</code>的<code>n-m+1</code>个可能值中的每一个，在第4行中比较相应字符的隐式循环必须执行<code>m</code>次来确定偏移的有效性。因此，最坏情况下的运行时间是Ο((n-m+1)m).由于不需要预处理，朴素字符串匹配算法运行时间即为其匹配时间。</p><h2 id="Rabin-Karp-算法">Rabin-Karp 算法</h2><p><strong>RK算法</strong>的核心思想就是通过计算<code>模式串</code>的哈希值与<code>文本串中每个长度等于模式串的子串</code>的哈希值进行比较，从而减少匹配的次数。当然，为了节省资源，哈希函数一般是由自己编写。同时，为了避免哈希碰撞产生的误判，哈希值相同的字符串还需要进行一次匹配验证。</p><p>一般情况下，算法的哈希函数会这么实现：取一个基数<code>d</code>（一般是字符串中出现的字符种类个数）和素数<code>q</code>，将每一个字符与<code>1~d</code>中的一个数匹配，此时字符串<code>S</code>可以视为一串数。将<code>S</code>转化为<code>d+1进制</code>的数，通常这个数会比较大，将其<code>mod q</code>(如：1e9+7) 得到一个较小的数，取这个数作为字符串的哈希值。</p><p>字符串哈希需要注意一下发生碰撞的概率。当我们对<code>M</code>取模时，则在计算根号M次时，就极易发生碰撞(生日攻击)。在进行n = 1e6 次计算，M = 1e9+7 ，则有1/1000的概率会发生碰撞。实际上在算法竞赛中，单哈希已经不安全了 ，例如题目 Hash Killer 2 就是让你构造一组数据去卡住<code>M = 1e9+7</code> 的哈希。所以常见的方法是双哈希，即取<code>M1</code>，<code>M2</code> 两个不同的模数，这样值域就被扩展到了<code>M1*M2</code>上，极大减少了实际上可以卡住的构造方法。</p><h6 id="伪代码-2">伪代码</h6><p>输入是文本<code>T</code>, 模式<code>P</code>, 使用基数<code>d</code>和素数<code>q</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RABIN-KARP-MATCHER(T,P,d,q) </span><br><span class="line">n = T.length </span><br><span class="line">m = P.length </span><br><span class="line">h = d^(m-1) mod q </span><br><span class="line">p = 0</span><br><span class="line">t_0 = O</span><br><span class="line">for i = 1 to m// preprocessing </span><br><span class="line">p = (d*p+P[i]） mod q </span><br><span class="line">t_0 = (d*t_0+T[i]) mod q </span><br><span class="line">for s = 0 to n-m// matching </span><br><span class="line">    if p == t, </span><br><span class="line">        if P[1..m] == T[s+1..s十m]</span><br><span class="line">        print&quot;Pattern occurs with shift&quot; s </span><br><span class="line">    if s &lt; n-m </span><br><span class="line">    t_(s+1) = (d*(t_s - T[s+1]*h) + T[s+m+1]) mod q </span><br></pre></td></tr></table></figure><p>RABIN-KARP-MATCHER 执行过程如下。所有的字符都假设是<code>d</code>进制的数字。仅为了说明的清楚，给t添加了下标，去除所有下标不会影响程序运行。第 4 行初始化m位窗口中高位上的值<code>h</code>。第 5~9 行计算出<code>P[1..m] mod q </code>的值<code>p</code>, 计算出 <code>T[1.. m] mod q</code>的值 t~0~ 。第 10~15 行的 for 循环迭代便利了所有可能的偏移s, 保持如下的不变量：</p><p>​第 11 行无论何时执行，都有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub><mo>=</mo><mi>T</mi><mo stretchy="false">[</mo><mi>s</mi><mo>+</mo><mn>1</mn><mo>…</mo><mi>s</mi><mo>+</mo><mi>m</mi><mo stretchy="false">]</mo><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>q</mi></mrow><annotation encoding="application/x-tex">t_s = T[s+1\dots s+m] \mod q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">]</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span></p><p>如果在第 11 行中有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">p=t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(一个“命中点&quot;)那么在第 12 行检测是否 P[1…m] = T[s+1…s+m], 用以排除它是伪命中点的可能性。第 13 行打印出所有找到的有效偏移。如果<code>s &lt; n-m</code>(在第14行检测)，则至少再执行一次for循环，这时首先执行第 15 行以保证再次执行到第 11 行时循环不变式依然成立。第 14 行直接利用等式</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>s</mi></msub><mo>−</mo><mi>T</mi><mo stretchy="false">[</mo><mi>s</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mi>h</mi><mo stretchy="false">)</mo><mo>+</mo><mi>T</mi><mo stretchy="false">[</mo><mi>s</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>q</mi></mrow><annotation encoding="application/x-tex">t_{s+1} = (d(t_s-T[s+1]h) + T[s+m+1]) \mod q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8234em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span></p><p>就可以在常数时间内由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>q</mi></mrow><annotation encoding="application/x-tex">t_s\mod q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 的值计算出  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>q</mi></mrow><annotation encoding="application/x-tex">t_{s+1}\mod q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8234em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>的值。</p><h6 id="复杂度">复杂度</h6><p><code>RABIN-KARP-MATCHER</code>的预处理时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>, 在最坏情况下，它的匹配时间是 ,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ο((n-m+1)m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">O</span><span class="mopen">((</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 因为<code>Rabin-Karp</code>算法和朴素字符串匹配算法一样，对每个有效偏移进行显式验证。如果P=a^m^并且T=a^n^, 由于在<code>n—m+1</code>个可能的偏移中每一个都是有效的，则验证所需的时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ο((n-m+1)m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">O</span><span class="mopen">((</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</p><p>当然，在一般情况下，算法所需的时间并不会达到最大。除非特地构造，每一个偏移都有效的概率并不比彩票实现财富自由的几率高。我们可以通过严谨的数学证明得到这种算法的期望运行时间：(别问我，我不会)</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)+O(m(v+n/q))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">))</span></span></span></span></p><p>其中<code>v</code>是有效偏移量。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v=O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>≥</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">q\geq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, 则这个算法的运行时间是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。也就是说，如果期望的有效偏移量很少(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>) ，而选取的素数<code>q</code>大于模式的长度，则可以估计Rabin-Karp算法的匹配时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>, 由于m&lt;=n, 这个算法的期望匹配时间是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="利用有限自动机进行字符串匹配">利用有限自动机进行字符串匹配</h2><p>复杂且效率不如KMP，过。（其实是没搞明白，数学证明好多）</p><h2 id="Knuth-Morris-Pratt-算法">Knuth-Morris-Pratt 算法</h2><p><strong>KMP算法</strong>通过计算字符串子串的最长公共前后缀，从而减少字符串匹配次数，达到提高效率的目的。</p><h3 id="python代码">python代码</h3><p>伪代码太抽象了，还不如直接写出来。代码段由GPT-4o生成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_lps</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算模式字符串的最长前缀后缀数组（LPS数组）。</span></span><br><span class="line"><span class="string">    LPS数组表示模式字符串中每个前缀的最长前缀后缀的长度。</span></span><br><span class="line"><span class="string">    有些（应该说很多）时候被叫做NEXT数组。</span></span><br><span class="line"><span class="string">    不更改的原因是偷懒（bushi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    pattern (str): 模式字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    list: 模式字符串的LPS数组</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lps = [<span class="number">0</span>] * <span class="built_in">len</span>(pattern)  <span class="comment"># 初始化LPS数组，长度与模式字符串相同，初始值为0</span></span><br><span class="line">    length = <span class="number">0</span>  <span class="comment"># 记录最长前缀后缀的长度</span></span><br><span class="line">    i = <span class="number">1</span>  <span class="comment"># 从第二个字符开始计算LPS值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(pattern):</span><br><span class="line">        <span class="keyword">if</span> pattern[i] == pattern[length]: <span class="comment"># 使用双指针比较</span></span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            lps[i] = length</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> length != <span class="number">0</span>:</span><br><span class="line">                length = lps[length - <span class="number">1</span>] <span class="comment"># 让前指针回到可能出现匹配字符串的位置继续比较</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lps[i] = <span class="number">0</span> <span class="comment"># 所有位置都不符合，没有公共串</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kmp_search</span>(<span class="params">text, pattern</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用KMP算法在文本字符串中搜索模式字符串的位置。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    text (str): 文本字符串</span></span><br><span class="line"><span class="string">    pattern (str): 模式字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    list: 模式字符串在文本字符串中的起始索引列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lps = compute_lps(pattern)  <span class="comment"># 计算模式字符串的LPS数组</span></span><br><span class="line">    result = []  <span class="comment"># 存储匹配的起始索引</span></span><br><span class="line">    i = <span class="number">0</span>  <span class="comment"># 文本字符串的索引</span></span><br><span class="line">    j = <span class="number">0</span>  <span class="comment"># 模式字符串的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(text):</span><br><span class="line">        <span class="keyword">if</span> pattern[j] == text[i]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(pattern):</span><br><span class="line">            result.append(i - j)</span><br><span class="line">            j = lps[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> i &lt; <span class="built_in">len</span>(text) <span class="keyword">and</span> pattern[j] != text[i]:</span><br><span class="line">            <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                j = lps[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试样例1</span></span><br><span class="line">text1 = <span class="string">&quot;AAABABAAABABAAABABAA&quot;</span></span><br><span class="line">pattern1 = <span class="string">&quot;ABABAAABABAA&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文本字符串：&quot;</span>, text1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;模式字符串：&quot;</span>, pattern1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;匹配的起始索引：&quot;</span>, kmp_search(text1, pattern1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;lps数组&quot;</span>, compute_lps(pattern1))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">文本字符串： AAABABAAABABAAABABAA</span></span><br><span class="line"><span class="string">模式字符串： ABABAAABABAA</span></span><br><span class="line"><span class="string">匹配的起始索引： [2, 8]</span></span><br><span class="line"><span class="string">lps数组 [0, 0, 1, 2, 3, 1, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="正确性解释（粗）">正确性解释（粗）</h3><h4 id="1-LPS数组的正确性">1. LPS数组的正确性</h4><p>定义：对于模式字符串 $ P=P[0]P[1]…P[m−1] $，LPS数组的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>P</mi><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">LPS[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 是使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mi>P</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>…</mo><mi>P</mi><mo stretchy="false">[</mo><mi>L</mi><mi>P</mi><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P[0]P[1]…P[LPS[i]−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>L</mi><mi>P</mi><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mi>P</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>L</mi><mi>P</mi><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mo stretchy="false">]</mo><mo>…</mo><mi>P</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P[i−LPS[i]+1]P[i−LPS[i]+2]…P[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>的最大值。</p><p><strong>证明</strong>：</p><ul><li>初始时， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>P</mi><mi>S</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">LPS[0]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，因为没有比自身更短的前缀。</li><li>对于每个<code>i</code>从<code>1</code>到<code>m−1</code>：<ul><li>如果 $ P[i]==P[length]$，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>P</mi><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">LPS[i]=length+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，即新增的字符与之前最长共同前后缀的下一个字符一致，共同前后缀的长度增加1， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">length+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，继续比较下一个字符。</li><li>否则，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span> 设置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>P</mi><mi>S</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">LPS[length−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，然后继续比较。当发生不匹配时，我们将前指针往回移动一位，并且取其LPS的值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>P</mi><mi>S</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">LPS[length−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>赋值给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span>，意味着 <strong>下一次循环会从该位的最长共同前后缀的下一位开始比较</strong> 。由于我们可以确定后指针的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><msub><mi>h</mi><mtext>赋值前</mtext></msub></mrow><annotation encoding="application/x-tex">length_{赋值前}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">赋值前</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 项相同，所以<strong>前字符串的最大相同前缀和后字符串的最大相同后缀相同</strong>。如果前字符串的最长共同前后缀的下一位与当前后指针所指字符相同，则共同前后缀的长度增加1，继续比较下一位；如果不同，则重复上述步骤。</li></ul></li></ul><blockquote><p><strong>注意！在这段代码中，<code>LPS[i]</code>的值代表了最长公共前后缀的长度，而<code>P[i]</code>是在字符串上第 <code>i+1</code> 位的字符（代码中字符串从<code>[0]</code>开始储存）。因此即<code>P[LPS[l-1]]</code>代表了 <code>找到的最长共前子串的后一个</code> 字符。这就是代码中没有出现很多模板中采用的<code>P[l+1]</code>的原因。这种写法保持了代码的简洁性（不需要预处理字符串、更少的计算符号），同时也带来了一些理解阻碍。不过在这种并不会毁坏代码可读性的情况下，更加简洁优雅的代码显然是应该被采纳的写法。</strong></p></blockquote><h4 id="2-主循环中的正确性">2. 主循环中的正确性</h4><p>KMP算法的主循环通过模式字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>和文本字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>的匹配过程进行描述：</p><p><strong>定义</strong>：</p><ul><li>$i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>是文本字符串</mtext></mrow><annotation encoding="application/x-tex">是文本字符串</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">是文本字符串</span></span></span></span>T$的当前索引。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>是模式字符串的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>当前索引。</li></ul><p><strong>主循环步骤</strong>：</p><ol><li>如果$ P[j] == T[i]<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，则</mtext></mrow><annotation encoding="application/x-tex">，则</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">，则</span></span></span></span>i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>和</mtext></mrow><annotation encoding="application/x-tex">和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">和</span></span></span></span>j$同时增加1。</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，表示匹配成功，将匹配的起始索引加入结果列表，然后通过$ LPS[j-1]$继续寻找下一个匹配。</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mi>T</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P[j] \neq T[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>：<ul><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>为$ LPS[j-1]<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，并且不增加</mtext></mrow><annotation encoding="application/x-tex">，并且不增加</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">，并且不增加</span></span></span></span>i $。</li><li>否则，仅增加$i $。</li></ul></li></ol><h5 id="证明匹配过程不回溯">证明匹配过程不回溯</h5><p>假设在$ T[i] $处发生不匹配：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>是模式字符串中的当前位置。</li><li>由于$ j = LPS[j-1]<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，这意味着我们已经匹配了</mtext></mrow><annotation encoding="application/x-tex">，这意味着我们已经匹配了</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">，这意味着我们已经匹配了</span></span></span></span>P[0]P[1]…P[LPS[j-1]-1]$。</li><li>因为 $ LPS[j-1]$是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mi>P</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>P</mi><mo stretchy="false">[</mo><mi>L</mi><mi>P</mi><mi>S</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P[0]P[1]...P[LPS[j-1]-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05764em;">PS</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的最长前缀后缀，所以在$ T[i] $处发生不匹配时，模式字符串中的前缀已经被考虑。</li></ul><h3 id="复杂度-2">复杂度</h3><h4 id="时间复杂度-2">时间复杂度</h4><p>KMP算法主要包括两个步骤：</p><ol><li>计算模式字符串的LPS（最长前缀后缀）数组。</li></ol><p>计算LPS数组的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中<code>m</code>是模式字符串的长度。具体分析如下：</p><ul><li>初始化LPS数组需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 时间。</li><li>在计算过程中，每个字符最多被访问两次（一次用于匹配，一次用于跳转），因此整体时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。</li></ul><ol start="2"><li>使用LPS数组在文本字符串中进行模式匹配。</li></ol><p>使用LPS数组进行模式匹配的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中<code>n</code>是文本字符串的长度。具体分析如下：</p><ul><li>每个字符最多被访问两次（一次用于匹配，一次用于跳转），因此整体时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li></ul><p>将两个步骤的时间复杂度相加，总时间复杂度为：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m) + O(n) = O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><h4 id="空间复杂度">空间复杂度</h4><p>KMP算法的空间复杂度主要由存储LPS数组的空间决定。</p><ul><li>LPS数组的长度为 (m)，因此需要 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>) 的空间。</li><li>除此之外，算法本身只使用了常数级别的额外空间（若干个变量）。</li></ul><p>总空间复杂度为：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> String </tag>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2024/06/17/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2024/06/17/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>最小生成树</h1><blockquote><p>在阅读下列内容之前，请了解 图 和 树 相关内容，并了解以下定义：</p><ol><li>生成子图</li><li>生成树</li></ol></blockquote><h2 id="定义">定义</h2><p>我们定义无向连通图的 <strong>最小生成树</strong>（Minimum Spanning Tree，MST）为边权和最小的生成树。</p><p>注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。</p><h2 id="Kruskal-算法">Kruskal 算法</h2><p>Kruskal 算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。</p><h3 id="前置知识">前置知识</h3><p>并查集、<a href="https://aullchen.github.io/2023/11/12/%E8%B4%AA%E5%BF%83/">贪心</a>、图的存储。</p><h3 id="实现">实现</h3><p>伪代码：（不写正经代码是因为不想写并查集……真想看去找AI吧~）</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="bold">Input.</mtext><mtext> </mtext></mrow><mtext>The edges of the graph </mtext><mi>e</mi><mo separator="true">,</mo><mtext> where each element in </mtext><mi>e</mi><mtext> is </mtext><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> denoting that there is an edge between </mtext><mi>u</mi><mtext> and </mtext><mi>v</mi><mtext> weighted </mtext><mi>w</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="bold">Output.</mtext><mtext> </mtext></mrow><mtext>The edges of the MST of the input graph</mtext><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext mathvariant="bold">Method.</mtext><mtext> </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo>←</mo><mi mathvariant="normal">∅</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>sort </mtext><mi>e</mi><mtext> into nondecreasing order by weight </mtext><mi>w</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>6</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext mathvariant="bold">for</mtext><mtext> each </mtext><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mtext> in the sorted </mtext><mi>e</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mspace width="2em"/><mrow><mtext mathvariant="bold">if</mtext><mtext> </mtext></mrow><mi>u</mi><mtext> and </mtext><mi>v</mi><mtext> are not connected in the union-find set </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mspace width="2em"/><mspace width="2em"/><mtext>connect </mtext><mi>u</mi><mtext> and </mtext><mi>v</mi><mtext> in the union-find set</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mspace width="2em"/><mspace width="2em"/><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo>←</mo><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mtext>  </mtext><mo>⋃</mo><mtext> </mtext><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>10</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mtext mathvariant="bold">return</mtext><mtext> </mtext></mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{ll}1 &amp;  \textbf{Input. } \text{The edges of the graph } e , \text{ where each element in } e \text{ is } (u, v, w) \\  &amp;  \text{ denoting that there is an edge between } u \text{ and } v \text{ weighted } w . \\2 &amp;  \textbf{Output. } \text{The edges of the MST of the input graph}.\\3 &amp;  \textbf{Method. } \\ 4 &amp;  result \gets \varnothing \\5 &amp;  \text{sort } e \text{ into nondecreasing order by weight } w \\ 6 &amp;  \textbf{for} \text{ each } (u, v, w) \text{ in the sorted } e \\ 7 &amp;  \qquad \textbf{if } u \text{ and } v \text{ are not connected in the union-find set } \\8 &amp;  \qquad\qquad \text{connect } u \text{ and } v \text{ in the union-find set} \\9 &amp;  \qquad\qquad  result \gets result\;\bigcup\ \{(u, v, w)\} \\10 &amp;  \textbf{return }  result\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:13.2em;vertical-align:-6.35em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.85em;"><span style="top:-9.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-7.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-6.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:0.59em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:1.79em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span></span></span><span style="top:2.99em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">10</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.85em;"><span style="top:-9.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord textbf">Input. </span></span><span class="mord text"><span class="mord">The edges of the graph </span></span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord"> where each element in </span></span><span class="mord mathnormal">e</span><span class="mord text"><span class="mord"> is </span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span><span style="top:-7.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> denoting that there is an edge between </span></span><span class="mord mathnormal">u</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord text"><span class="mord"> weighted </span></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">.</span></span></span><span style="top:-6.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord textbf">Output. </span></span><span class="mord text"><span class="mord">The edges of the MST of the input graph</span></span><span class="mord">.</span></span></span><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord textbf">Method. </span></span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord amsrm">∅</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">sort </span></span><span class="mord mathnormal">e</span><span class="mord text"><span class="mord"> into nondecreasing order by weight </span></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord textbf">for</span></span><span class="mord text"><span class="mord"> each </span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mord text"><span class="mord"> in the sorted </span></span><span class="mord mathnormal">e</span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord textbf">if </span></span><span class="mord mathnormal">u</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord text"><span class="mord"> are not connected in the union-find set </span></span></span></span><span style="top:0.59em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord text"><span class="mord">connect </span></span><span class="mord mathnormal">u</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord text"><span class="mord"> in the union-find set</span></span></span></span><span style="top:1.79em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⋃</span><span class="mspace"> </span><span class="mopen">{(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)}</span></span></span><span style="top:2.99em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord textbf">return </span></span><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p>算法虽简单，但需要相应的数据结构来支持……</p><p>具体来说，维护一个森林，查询两个结点是否在同一棵树中，连接两棵树。</p><p>抽象一点地说，维护一堆 <strong>集合</strong>，查询两个元素是否属于同一集合，合并两个集合。</p><p>其中，查询两点是否连通和连接两点可以使用并查集维护。</p><p>如果使用 <code>O(mlogm)</code> 的排序算法，并且使用 <code>O(mα(m, n))</code> 或 <code>O(mlogn)</code> 的并查集，就可以得到时间复杂度为 <code>O(mlogm)</code> 的 Kruskal 算法。</p><h3 id="证明">证明</h3><p>思路很简单，为了造出一棵最小生成树，我们从最小边权的边开始，按边权从小到大依次加入，如果某次加边产生了环，就扔掉这条边，直到加入了 <code>n-1</code> 条边，即形成了一棵树。</p><p>证明：使用归纳法，证明任何时候 K 算法选择的边集都被某棵 MST 所包含。</p><p>基础：对于算法刚开始时，显然成立（最小生成树存在）。</p><p>归纳：假设某时刻成立，当前边集为 <code>F</code>，令 <code>T</code> 为这棵 MST，考虑下一条加入的边 <code>e</code>。</p><p>如果 <code>e</code> 属于 <code>T</code>，那么成立。</p><p>否则，<code>T+e</code> 一定存在一个环，考虑这个环上不属于 <code>F</code> 的另一条边 <code>f</code>（一定只有一条）。</p><p>首先，<code>f</code> 的权值一定不会比 <code>e</code> 小，不然 <code>f</code> 会在 <code>e</code> 之前被选取。</p><p>然后，<code>f</code> 的权值一定不会比 <code>e</code> 大，不然 <code>T+e-f</code> 就是一棵比 <code>T</code> 还优的生成树了。</p><p>所以，<code>T+e-f</code> 包含了 <code>F</code>，并且也是一棵最小生成树，归纳成立。</p><h2 id="Prim-算法">Prim 算法</h2><p>Prim 算法是另一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。</p><h3 id="实现-2">实现</h3><h4 id="代码">代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">    <span class="comment"># 初始化图</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vertices</span>):</span><br><span class="line">        self.V = vertices</span><br><span class="line">        self.graph = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(vertices)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(vertices)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加边</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_edge</span>(<span class="params">self, u, v, weight</span>):</span><br><span class="line">        self.graph[u][v] = weight</span><br><span class="line">        self.graph[v][u] = weight</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找最短边</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min_key</span>(<span class="params">self, key, mst_set</span>):</span><br><span class="line">        min_value = sys.maxsize</span><br><span class="line">        min_index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(self.V):</span><br><span class="line">            <span class="keyword">if</span> key[v] &lt; min_value <span class="keyword">and</span> <span class="keyword">not</span> mst_set[v]:</span><br><span class="line">                min_value = key[v]</span><br><span class="line">                min_index = v</span><br><span class="line">        <span class="keyword">return</span> min_index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prim_mst</span>(<span class="params">self</span>):</span><br><span class="line">        parent = [-<span class="number">1</span>] * self.V<span class="comment"># 最小边的父节点，用来储存mst</span></span><br><span class="line">        key = [sys.maxsize] * self.V<span class="comment"># 初始化距离无穷远</span></span><br><span class="line">        key[<span class="number">0</span>] = <span class="number">0</span><span class="comment"># 源点置0</span></span><br><span class="line">        mst_set = [<span class="literal">False</span>] * self.V<span class="comment"># 访问标志初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.V):</span><br><span class="line">            u = self.min_key(key, mst_set)<span class="comment"># 寻找最短边</span></span><br><span class="line">            mst_set[u] = <span class="literal">True</span><span class="comment"># 将其归入已生成集</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新最小生成树</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(self.V):</span><br><span class="line">                <span class="keyword">if</span> self.graph[u][v] &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> mst_set[v] <span class="keyword">and</span> key[v] &gt; self.graph[u][v]:</span><br><span class="line">                    key[v] = self.graph[u][v]</span><br><span class="line">                    parent[v] = u</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parent</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 建图</span></span><br><span class="line">g = Graph(<span class="number">5</span>)</span><br><span class="line">g.add_edge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">g.add_edge(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">g.add_edge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">g.add_edge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>)</span><br><span class="line">g.add_edge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">g.add_edge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line">g.add_edge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">parent = g.prim_mst()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;边   权&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, g.V):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;parent[i]&#125;</span> - <span class="subst">&#123;i&#125;</span>    <span class="subst">&#123;g.graph[i][parent[i]]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="运行结果">运行结果</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">边   权</span><br><span class="line">0 - 1    2</span><br><span class="line">1 - 2    3</span><br><span class="line">0 - 3    6</span><br><span class="line">1 - 4    5</span><br></pre></td></tr></table></figure><h3 id="正确性">正确性</h3><p>从任意一个结点开始，将结点分成两类：已加入的，未加入的。</p><p>每次从未加入的结点中，找一个与已加入的结点之间边权最小值最小的结点。</p><p>然后将这个结点加入，并连上那条边权最小的边。</p><p>重复 <code>n-1</code> 次即可。</p><p>证明：还是说明在每一步，都存在一棵最小生成树包含已选边集。</p><p>基础：只有一个结点的时候，显然成立。</p><p>归纳：如果某一步成立，当前边集为 <code>F</code>，属于 <code>T</code> 这棵 MST，接下来要加入边 <code>e</code>。</p><p>如果 <code>e</code> 属于 <code>T</code>，那么成立。</p><p>否则考虑 <code>T+e</code> 中环上另一条可以加入当前边集的边 <code>f</code>。</p><p>首先，<code>f</code> 的权值一定不小于 <code>e</code> 的权值，否则就会选择 <code>f</code> 而不是 <code>e</code> 了。</p><p>然后，<code>f</code> 的权值一定不大于 <code>e</code> 的权值，否则 <code>T+e-f</code> 就是一棵更小的生成树了。</p><p>因此，<code>e</code> 和 <code>f</code> 的权值相等，<code>T+e-f</code> 也是一棵最小生成树，且包含了 <code>F</code>。</p><h3 id="复杂度">复杂度</h3><p>寻找最短边时，需要遍历所有未包括在最小生成树集合中且权重最小的顶点，时间复杂度为O(V)；选择最小边时，需要遍历所有顶点，时间复杂度也为O(V)。总共有V次选择最小边的操作，因此总时间复杂度为<code>O(V^2)</code>。</p><p>父节点数组<code>parent</code>、顶点到最小生成树的最小权重数组<code>key</code>和最小生成树集合标记数组<code>mst_set</code>的空间复杂度都为O(V)，没有使用额外的数据结构，所以总空间复杂度为<code>O(V)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Graph </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多源最短路</title>
      <link href="/2024/06/17/%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2024/06/17/%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1>多源最短路</h1><blockquote><p>请确保自己已经了解<strong>图</strong>的相关内容。包括但不限于：</p><ul><li>图，邻接表，邻接矩阵</li><li>路径，最短路，权，环</li><li>有向图，无向图</li><li>Dijkstra算法，Bellman-Ford算法</li></ul></blockquote><blockquote><blockquote><p>文中所有的证明都是不严谨的，详细数学证明可移步《算法导论》相关章节。</p></blockquote></blockquote><h2 id="定义">定义</h2><p>顾名思义，求一张图上所有节点到其他可连通节点的最短路径。</p><table><thead><tr><th>最短路算法</th><th>Floyd</th><th>Johnson</th><th>Dijkstra</th><th>Bellman–Ford</th></tr></thead><tbody><tr><td>最短路类型</td><td>每对结点之间的最短路</td><td>每对结点之间的最短路</td><td>单源最短路</td><td>单源最短路</td></tr><tr><td>作用于</td><td>任意图</td><td>任意图</td><td>非负权图</td><td>任意图</td></tr><tr><td>能否检测负环？</td><td>能</td><td>能</td><td>不能</td><td>能</td></tr><tr><td>时间复杂度</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NM\log M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">NM</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M\log M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NM)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">NM</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><p>注：表中的 Dijkstra 算法在计算复杂度时均用 <code>priority_queue</code> 实现。</p><h2 id="Floyd-算法">Floyd 算法</h2><p>弗洛伊德算法可以用来求任意两个结点之间的最短路。</p><p>复杂度比较高，但是常数小，容易实现（只有三个 <code>for</code>）。</p><p>适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）</p><h3 id="实现">实现</h3><p>我们定义一个数组 <code>f[k][x][y]</code>，表示只允许经过结点 <code>1</code> 到 <code>k</code>（也就是说，在子图 <code>V'=1, 2,..., k</code> 中的路径，注意，<code>x</code>与<code>y</code>不一定在这个子图中），结点<code>x</code>到结点<code>y</code>的最短路长度。</p><p>很显然，<code>f[n][x][y]</code> 就是结点<code>x</code>到结点<code>y</code>的最短路长度（因为 <code>V'=1, 2,..., k</code> 即为<code>V</code>本身，其表示的最短路径就是所求路径）。</p><p>接下来考虑如何求出 <code>f</code> 数组的值。</p><p><code>f[0][x][y]</code>：<code>x</code>与<code>y</code>的边权，或者<code>0</code>，或者 <code>+inf</code>（<code>f[0][x][y]</code>什么时候应该是 <code>+inf</code>？当<code>x</code>与<code>y</code>间有直接相连的边的时候，为它们的边权；当<code>x = y</code>的时候为零，因为到本身的距离为零；当<code>x</code>与<code>y</code>没有直接相连的边的时候，为 <code>+inf</code>）。</p><p><code>f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])</code>（<code>f[k-1][x][y]</code>，为不经过<code>k</code>点的最短路径，而 <code>f[k-1][x][k]+f[k-1][k][y]</code>，为经过了<code>k</code>点的最短路）。</p><p>上面两行都显然是对的，所以说这个做法空间是 <code>O(N^3)</code>，我们需要依次增加问题规模（<code>k</code>从<code>1</code>到<code>n</code>），判断任意两点在当前问题规模下的最短路。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                f[k][x][y] = <span class="built_in">min</span>(f[k - <span class="number">1</span>][x][y], f[k - <span class="number">1</span>][x][k] + f[k - <span class="number">1</span>][k][y])</span><br></pre></td></tr></table></figure><p>因为第一维对结果无影响，我们可以发现数组的第一维是可以省略的，于是可以直接改成 <code>f[x][y] = min(f[x][y], f[x][k]+f[k][y])</code>。</p><h4 id="证明第一维对结果无影响">证明第一维对结果无影响</h4><p>我们注意到如果放在一个给定第一维<code>k</code>二维数组中，<code>f[x][k]</code> 与 <code>f[k][y]</code> 在某一行和某一列。而 <code>f[x][y]</code> 则是该行和该列的交叉点上的元素。</p><p>现在我们需要证明将 <code>f[k][x][y]</code> 直接在原地更改也不会更改它的结果：我们注意到 <code>f[k][x][y]</code> 的涵义是第一维为 <code>k-1</code> 这一行和这一列的所有元素的最小值，包含了 <code>f[k-1][x][y]</code>，那么在原地进行更改也不会改变最小值的值，因为如果将该三维矩阵压缩为二维，则所求结果 <code>f[x][y]</code> 一开始即为原 <code>f[k-1][x][y]</code> 的值，最后依然会成为该行和该列的最小值。故可以压缩。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            f[x][y] = <span class="built_in">min</span>(f[x][y], f[x][k] + f[k][y])</span><br></pre></td></tr></table></figure><p>综上，时间复杂度是 <code>O(N^3)</code>，空间复杂度是 <code>O(N^2)</code>。</p><h3 id="前驱矩阵">前驱矩阵</h3><p>当然，很多时候我们需要的不仅仅是最短路径的距离，还要得到最短路径上经过的节点。此时我们可以引入一个<strong>前驱矩阵</strong>来实现这一功能。</p><p>前驱矩阵在弗洛伊德算法中用于记录每个节点对之间最短路径的前驱节点。通过其记录的数据，我们可以追溯从起始节点到目标节点的路径。通过不断查询前驱矩阵，可以从目标节点反向追溯到起始节点，从而得到完整的路径。同时，使用前驱矩阵可以在最短路径计算完成后快速查询任意两个节点之间的最短路径，而不需要重新计算。</p><h4 id="使用前驱矩阵重构路径的步骤">使用前驱矩阵重构路径的步骤</h4><ol><li><strong>初始化</strong>：初始化前驱矩阵<code>pred</code>，如果有直接边连接节点<code>i</code>和节点<code>j</code>，则<code>pred[i][j]</code>设为<code>i</code>。</li><li><strong>更新前驱矩阵</strong>：在更新距离矩阵<code>dist</code>的同时更新前驱矩阵<code>pred</code>。如果通过中间节点<code>k</code>可以缩短从节点<code>i</code>到节点<code>j</code>的路径，则更新<code>pred[i][j]</code>为<code>pred[k][j]</code>。</li><li><strong>重构路径</strong>：从目标节点开始，逐步查找前驱节点，直到到达起始节点，记录所经过的节点即可得到路径。</li></ol><h3 id="代码实现">代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">floyd_warshall_with_predecessor</span>(<span class="params">graph</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(graph)</span><br><span class="line">    dist = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    pred = [[<span class="literal">None</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                dist[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> graph[i][j] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">                dist[i][j] = graph[i][j]</span><br><span class="line">                pred[i][j] = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j]</span><br><span class="line">                    pred[i][j] = pred[k][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist, pred</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reconstruct_path</span>(<span class="params">predecessors, start, end</span>):</span><br><span class="line">    <span class="keyword">if</span> predecessors[start][end] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []  <span class="comment"># 表示没有路径</span></span><br><span class="line">    path = [end]</span><br><span class="line">    <span class="keyword">while</span> end != start:</span><br><span class="line">        end = predecessors[start][end]</span><br><span class="line">        path.append(end)</span><br><span class="line">    path.reverse()</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例图</span></span><br><span class="line">graph = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">3</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="number">5</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="number">4</span>],</span><br><span class="line">    [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)],</span><br><span class="line">    [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">distances, predecessors = floyd_warshall_with_predecessor(graph)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All-pairs shortest path matrix:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> distances:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPredecessor matrix:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> predecessors:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line">start, end = <span class="number">0</span>, <span class="number">3</span></span><br><span class="line">path = reconstruct_path(predecessors, start, end)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nShortest path from <span class="subst">&#123;start&#125;</span> to <span class="subst">&#123;end&#125;</span>: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="运行结果">运行结果</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">All-pairs shortest path matrix:</span><br><span class="line">[0, 3, 7, 5]</span><br><span class="line">[2, 0, 6, 4]</span><br><span class="line">[3, 1, 0, 5]</span><br><span class="line">[5, 4, 2, 0]</span><br><span class="line"></span><br><span class="line">Predecessor matrix:</span><br><span class="line">[None, 0, 1, 0]</span><br><span class="line">[1, None, 1, 1]</span><br><span class="line">[1, 2, None, 1]</span><br><span class="line">[2, 2, 3, None]</span><br><span class="line"></span><br><span class="line">Shortest path from 0 to 3: [0, 1, 3]</span><br></pre></td></tr></table></figure><h2 id="Johnson-算法">Johnson 算法</h2><p>Johnson 和 Floyd 一样，是一种能求出无负环图上任意两点间最短路径的算法。该算法在 1977 年由 Donald B. Johnson 提出。</p><p>任意两点间的最短路可以通过枚举起点，跑 <code>n</code> 次 Bellman–Ford 算法解决，时间复杂度是 <code>O(m*n^2)</code> 的，也可以直接用 Floyd 算法解决，时间复杂度为 <code>O(n^3)</code>。</p><p>注意到堆优化的 Dijkstra 算法求单源最短路径的时间复杂度比 Bellman–Ford 更优，如果枚举起点，跑 <code>n</code> 次 Dijkstra 算法，就可以在 <code>O(nmlogm)</code>（取决于 Dijkstra 算法的实现）的时间复杂度内解决本问题，比上述跑 <code>n</code> 次 Bellman–Ford 算法的时间复杂度更优秀，在稀疏图上也比 Floyd 算法的时间复杂度更加优秀。</p><p>但 Dijkstra 算法不能正确求解带负权边的最短路，因此我们需要对原图上的边进行预处理，确保所有边的边权均非负。</p><p>我们新建一个虚拟节点（在这里我们就设它的编号为 <code>0</code>）。从这个点向其他所有点连一条边权为 <code>0</code> 的边。</p><p>接下来用 Bellman–Ford 算法求出从 <code>0</code> 号点到其他所有点的最短路，记为 <code>h_i</code>。</p><p>假如存在一条从 <code>u</code> 点到 <code>v</code> 点，边权为 <code>w</code> 的边，则我们将该边的边权重新设置为 <code>w+h_u-h_v</code>。</p><p>接下来以每个点为起点，跑 <code>n</code> 轮 Dijkstra 算法即可求出任意两点间的最短路了。</p><p>一开始的 Bellman–Ford 算法并不是时间上的瓶颈，若使用 <code>priority_queue</code> 实现 Dijkstra 算法，该算法的时间复杂度是 <code>O(nmlogm)</code>。</p><h3 id="正确性证明">正确性证明</h3><p>在重新标记后的图上，从 <code>s</code> 点到 <code>t</code> 点的一条路径 <code>s -&gt; p_1 -&gt; p_2 -&gt; ... -&gt; p_k -&gt; t</code> 的长度表达式如下：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>h</mi><mi>s</mi></msub><mo>−</mo><msub><mi>h</mi><msub><mi>p</mi><mn>1</mn></msub></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>h</mi><msub><mi>p</mi><mn>1</mn></msub></msub><mo>−</mo><msub><mi>h</mi><msub><mi>p</mi><mn>2</mn></msub></msub><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>k</mi></msub><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>h</mi><msub><mi>p</mi><mi>k</mi></msub></msub><mo>−</mo><msub><mi>h</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(w(s,p_1)+h_s-h_{p_1})+(w(p_1,p_2)+h_{p_1}-h_{p_2})+ \dots +(w(p_k,t)+h_{p_k}-h_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>化简后得到：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>w</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>k</mi></msub><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>h</mi><mi>s</mi></msub><mo>−</mo><msub><mi>h</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">w(s,p_1)+w(p_1,p_2)+ \dots +w(p_k,t)+h_s-h_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>无论我们从 <code>s</code> 到 <code>t</code> 走的是哪一条路径，<code>h_s - h_t</code>的值是不变的，这正与物理中势能的性质相吻合！</p><p>为了方便，下面我们就把 <code>h_i</code> 称为 <code>i</code> 点的势能。</p><p>上面的新图中 <code>s -&gt; t</code> 的最短路的长度表达式由两部分组成，前面的边权和为原图中 <code>s -&gt; t</code> 的最短路，后面则是两点间的势能差。因为两点间势能的差为定值，因此原图上 <code>s -&gt; t</code> 的最短路与新图上 <code>s -&gt; t</code> 的最短路相对应。</p><p>到这里我们的正确性证明已经解决了一半——我们证明了重新标注边权后图上的最短路径仍然是原来的最短路径。接下来我们需要证明新图中所有边的边权非负，因为在非负权图上，Dijkstra 算法能够保证得出正确的结果。</p><p>根据三角形不等式，图上任意一边 <code>(u,v)</code> 上两点满足：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>v</mi></msub><mo>≤</mo><msub><mi>h</mi><mi>u</mi></msub><mo>+</mo><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_v \leq h_u + w(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>。这条边重新标记后的边权为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>h</mi><mi>u</mi></msub><mo>−</mo><msub><mi>h</mi><mi>v</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">w&#x27;(u,v)=w(u,v)+h_u-h_v \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。这样我们证明了新图上的边权均非负。</p><p>这样，我们就证明了 Johnson 算法的正确性。</p><h3 id="代码">代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bellman_ford</span>(<span class="params">graph, source</span>):</span><br><span class="line">    distance = &#123;v: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> v <span class="keyword">in</span> graph&#125;</span><br><span class="line">    distance[source] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">for</span> v, weight <span class="keyword">in</span> graph[u]:</span><br><span class="line">                <span class="keyword">if</span> distance[u] + weight &lt; distance[v]:</span><br><span class="line">                    distance[v] = distance[u] + weight</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查负权重环路</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">for</span> v, weight <span class="keyword">in</span> graph[u]:</span><br><span class="line">            <span class="keyword">if</span> distance[u] + weight &lt; distance[v]:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;Graph contains a negative-weight cycle&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, source</span>):</span><br><span class="line">    pq = [(<span class="number">0</span>, source)]</span><br><span class="line">    distance = &#123;v: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> v <span class="keyword">in</span> graph&#125;</span><br><span class="line">    distance[source] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        current_distance, u = heapq.heappop(pq)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> current_distance &gt; distance[u]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v, weight <span class="keyword">in</span> graph[u]:</span><br><span class="line">            distance_v = current_distance + weight</span><br><span class="line">            <span class="keyword">if</span> distance_v &lt; distance[v]:</span><br><span class="line">                distance[v] = distance_v</span><br><span class="line">                heapq.heappush(pq, (distance_v, v))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">johnson</span>(<span class="params">graph</span>):</span><br><span class="line">    new_graph = &#123;v: <span class="built_in">list</span>(graph[v]) <span class="keyword">for</span> v <span class="keyword">in</span> graph&#125;</span><br><span class="line">    new_graph[<span class="string">&#x27;new_node&#x27;</span>] = [(v, <span class="number">0</span>) <span class="keyword">for</span> v <span class="keyword">in</span> graph]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行Bellman-Ford算法</span></span><br><span class="line">    h = bellman_ford(new_graph, <span class="string">&#x27;new_node&#x27;</span>)</span><br><span class="line">    <span class="keyword">del</span> new_graph[<span class="string">&#x27;new_node&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调整边权重</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">for</span> i, (v, weight) <span class="keyword">in</span> <span class="built_in">enumerate</span>(new_graph[u]):</span><br><span class="line">            new_graph[u][i] = (v, weight + h[u] - h[v])</span><br><span class="line"></span><br><span class="line">    distances = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> graph:</span><br><span class="line">        distances[u] = dijkstra(new_graph, u)</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph:</span><br><span class="line">            distances[u][v] = distances[u][v] - h[u] + h[v]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distances</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例图，使用邻接表表示</span></span><br><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: [(<span class="string">&#x27;B&#x27;</span>, -<span class="number">2</span>)],</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: [(<span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>)],</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: [(<span class="string">&#x27;A&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算所有节点之间的最短路径</span></span><br><span class="line">distances = johnson(graph)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All-pairs shortest path matrix:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> u <span class="keyword">in</span> distances:</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> distances[u]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Shortest path from <span class="subst">&#123;u&#125;</span> to <span class="subst">&#123;v&#125;</span> is <span class="subst">&#123;distances[u][v]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="运行结果-2">运行结果</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">All-pairs shortest path matrix:</span><br><span class="line">Shortest path from A to A is 0</span><br><span class="line">Shortest path from A to B is -2</span><br><span class="line">Shortest path from A to C is -1</span><br><span class="line">Shortest path from B to A is 5</span><br><span class="line">Shortest path from B to B is 0</span><br><span class="line">Shortest path from B to C is 1</span><br><span class="line">Shortest path from C to A is 4</span><br><span class="line">Shortest path from C to B is 2</span><br><span class="line">Shortest path from C to C is 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单源最短路</title>
      <link href="/2024/06/17/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2024/06/17/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1>单源最短路</h1><blockquote><p>请确保自己已经了解<strong>图</strong>的相关内容。包括但不限于：</p><ul><li>图，邻接表，邻接矩阵</li><li>路径，最短路，权，环</li><li>有向图，无向图</li></ul></blockquote><h2 id="定义">定义</h2><p>顾名思义，求单一起点到其他可连通节点的最短路径。有两种比较经典的算法：</p><table><thead><tr><th>最短路算法</th><th>Dijkstra</th><th>Bellman–Ford</th></tr></thead><tbody><tr><td>最短路类型</td><td>单源最短路</td><td>单源最短路</td></tr><tr><td>作用于</td><td>非负权图</td><td>任意图</td></tr><tr><td>能否检测负环？</td><td>不能</td><td>能</td></tr><tr><td>时间复杂度</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M\log M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NM)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">NM</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><p>注：表中的 Dijkstra 算法在计算复杂度时均用 <code>priority_queue</code> 实现。</p><h2 id="Dijkstra">Dijkstra</h2><p><strong>迪杰斯特拉算法</strong>是一个经典的求单源最短路的算法。其优点是容易理解，在数据量不大的情况下拥有较好的效率。缺点则是无法处理存在<strong>负权边</strong>的图。</p><h3 id="过程">过程</h3><p>先介绍<strong>Dijkstra算法</strong>要用到的<strong>松弛操作</strong>（后面的<strong>Bellman–Ford算法</strong>也会用到松弛操作）。</p><p>对于边<code>(u,v)</code><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="(u,v)">，松弛操作对应下面的式子：<code>dis(v)=min(dis(v), dis(u)+w(u,v))</code>。</p><p>这么做的含义是显然的：我们尝试用<code>S-&gt;u-&gt;v</code>（其中<code>S-&gt;u</code>的路径取最短路）这条路径去更新<code>v</code>点最短路的长度，如果这条路径更优，就进行更新。</p><p>再来看<strong>Dijkstra算法</strong>。</p><p>将结点分成两个集合：已确定最短路长度的点集（记为<code>S</code> 集合）的和未确定最短路长度的点集（记为<code>T</code>集合）。一开始所有的点都属于<code>T</code>集合。</p><p>初始化<code>dis(s)=0</code>，其他点的<code>dis</code>均为<code>+inf</code>。</p><p>然后重复这些操作：</p><ol><li>从<code>T</code>集合中，选取一个最短路长度最小的结点，移到<code>S</code>集合中。</li><li>对那些刚刚被加入<code>S</code>集合的结点的所有出边执行松弛操作。</li></ol><p>直到<code>T</code>集合为空，算法结束。</p><h3 id="实现">实现</h3><h5 id="代码">代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化距离字典，将起点距离设为0，其他点距离设为无穷大</span></span><br><span class="line">    distances = &#123;vertex: <span class="built_in">float</span>(<span class="string">&#x27;infinity&#x27;</span>) <span class="keyword">for</span> vertex <span class="keyword">in</span> graph&#125;</span><br><span class="line">    distances[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用优先队列存储顶点和对应的距离</span></span><br><span class="line">    pq = [(<span class="number">0</span>, start)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        current_distance, current_vertex = heapq.heappop(pq)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果当前顶点的距离大于已知最短路径的距离，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> current_distance &gt; distances[current_vertex]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[current_vertex].items():</span><br><span class="line">            distance = current_distance + weight</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果新路径比已知的最短路径还要短，则更新距离和优先队列</span></span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances[neighbor]:</span><br><span class="line">                distances[neighbor] = distance</span><br><span class="line">                heapq.heappush(pq, (distance, neighbor))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distances</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建图</span></span><br><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># A为源点测试</span></span><br><span class="line">start_vertex = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">for</span> vertex, distance <span class="keyword">in</span> dijkstra(graph, start_vertex).items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;到达顶点 <span class="subst">&#123;vertex&#125;</span> 的距离为: <span class="subst">&#123;distance&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">到达顶点 A 的距离为: 0</span><br><span class="line">到达顶点 B 的距离为: 1</span><br><span class="line">到达顶点 C 的距离为: 3</span><br><span class="line">到达顶点 D 的距离为: 4</span><br></pre></td></tr></table></figure><h3 id="理论">理论</h3><h4 id="正确性">正确性</h4><blockquote><p>此证明包含大量盯真成分，仅供粗略理解。严谨数学证明可参考**《算法导论》第24章相关内容**</p><p><a href="https://zh.singlelogin.re/book/5442421/d42556/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88.html">算法导论（原书第3版） | Thomas H.Cormen,Charles E.Leiserson,Ronald L.Rivest,Clifford Stein | download on Z-Library (singlelogin.re)</a></p></blockquote><p><code>Dijkstra</code>的核心思想是贪心，通过局部最优累加出总体最优。要证明其正确性，关键在于证明局部的叠加能够得到整体最优解。</p><p>采取反证法。</p><p>假设存在一个顶点<code>v</code>，算法得出的从源点<code>s</code>到<code>v</code>的最短路径<code>d[v]</code> 不是当前最短路径，即存在一条更短的路径。令<code>u</code>为<code>d[v]</code>上<code>v</code>的<strong>任意</strong>前一顶点。</p><p>根据<code>Dijkstra</code>算法的贪心性质，其得出的结果总是有<code>d[u] + w(u, v) &gt;= d[v]</code>，其中<code>w(u, v)</code>为边<code>(u, v)</code>的权重，<code>d[u]</code>是源点<code>s</code>到<code>u</code>的最优解。</p><p>因此，<code>d[v]</code>不可能大于<code>d[u] + w(u, v)</code>。排除闪现的可能，即以通过权边的方式到达<code>v</code>，更短的路径不存在，假设不成立。因此可以认为<code>Dijkstra</code>算法得到的最短路径是最优的。</p><h4 id="时间复杂度">时间复杂度</h4><h6 id="朴素Dijkstra">朴素Dijkstra</h6><p>假设图有<code>V</code>个顶点和<code>E</code>条边：</p><ol><li>初始化所有顶点的距离为无穷大，标记数组表示是否已经找到最短路径：O(V)。</li><li>执行<code>V</code>次循环，每次找到距离最小且未被标记的顶点，遍历所有顶点来找到距离最小的顶点：O(V^2^)。</li><li>对于每个被选中的顶点，考虑每条边一次，以更新其相邻顶点的距离：O(E)。</li></ol><p>综上所述，<strong>朴素Dijkstra</strong>算法的总时间复杂度为O(V^2^ + E)。如果图是稀疏的（即E接近V^2^），则可以将时间复杂度简化为O(V^2^)。</p><h6 id="优先队列优化">优先队列优化</h6><p>使用<strong>最小堆</strong>实现优先队列，假设图有<code>V</code>个顶点和<code>E</code>条边：</p><ol><li>初始化距离数组和优先队列：O(V)。</li><li>在优先队列不为空时执行循环，最坏情况下需要执行V次：<ul><li>从优先队列中弹出顶点：O(logV)。每次弹出都要调整堆，最坏情况下是堆的高度<code>logV</code>。</li><li>对于每个弹出的顶点，遍历其所有邻居并更新距离：O(E)。在最坏情况下，每个边都会被考虑一次。</li><li>更新优先队列中的顶点：O(logV)。更新优先队列中的顶点的距离可能需要调整堆。</li></ul></li></ol><p>综上，<strong>优化Dijkstra</strong>总时间复杂度为 O(VlogV + ElogV)。如果图是稀疏的（即E接近V^2^），则可以将时间复杂度简化为  O( (V+E) logV )。</p><h4 id="空间复杂度">空间复杂度</h4><h6 id="朴素Dijkstra-2">朴素Dijkstra</h6><p>实现该算法需要一个大小为<code>V</code>的数组来存储每个顶点到起始顶点的距离，空间复杂度为O(V)；需要一个大小为<code>V</code>的数组来标记每个顶点是否已经找到最短路径，空间复杂度为O(V)；需要一个大小为 V^2^ 的矩阵或 V 个链表来表示图中顶点之间的关系。空间复杂度为O(V^2^)或O(E)，取决于图的稠密程度。其他变量和数据结构如临时变量、堆栈等的空间消耗通常是常量级别的，可以忽略不计。</p><p>综上所述，朴素Dijkstra算法的总空间复杂度为 O(V^2^)</p><h6 id="优先队列优化-2">优先队列优化</h6><p>需要一个大小为V的数组来存储每个顶点到源点的最短距离，空间复杂度为O(V)；优先队列的大小最多为V，因为每个顶点最多只会入队一次，空间复杂度为O(V)；邻接矩阵或邻接列表空间复杂度为O(V^2^)或O(E)。</p><p>因此，使用优先队列优化的Dijkstra算法的总空间复杂度为 O(V)~（距离数组）~+ O(V)~（优先队列）~+ O(V^2^)或O(E)~（邻接矩阵或邻接列表）~。</p><h2 id="Bellman-Ford">Bellman-Ford</h2><p><strong>贝尔曼福特算法</strong>是一种基于松弛（relax）操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断。</p><p>在国内OI界，你可能听说过的**「SPFA」<strong>，就是</strong>Bellman–Ford算法**的一种实现。</p><h3 id="过程-2">过程</h3><p>回顾前面的<strong>松弛操作</strong>。</p><p>对于边<code>(u,v)</code><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="(u,v)">，松弛操作对应下面的式子：<code>dis(v)=min(dis(v), dis(u)+w(u,v))</code>。</p><p><strong>Bellman–Ford算法</strong>所做的，就是不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。</p><p>每次循环是<code>O(m)</code>的，那么最多会循环多少次呢？</p><p>在最短路存在的情况下，由于一次松弛操作会使最短路的边数至少<code>+1</code>，而最短路的边数最多为<code>n-1</code>，因此整个算法最多执行<code>n-1</code>轮松弛操作。故总时间复杂度为<code>O(nm)</code>。</p><p>但还有一种情况，如果从<code>s</code>点出发，抵达一个负环时，松弛操作会无休止地进行下去。注意到前面的论证中已经说明了，对于最短路存在的图，松弛操作最多只会执行<code>n-1</code>轮，因此如果第<code>n</code>轮循环时仍然存在能松弛的边，说明从<code>S</code>点出发，能够抵达一个负环。利用这个特点，我们可以实现对图中是否存在负环进行判断。</p><h3 id="实现-2">实现</h3><h5 id="代码-2">代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, u, v, weight</span>):</span><br><span class="line">        self.u = u</span><br><span class="line">        self.v = v</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bellman_ford</span>(<span class="params">edges, V, start</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化dist，将起点距离设为0，其他点距离设为无穷大</span></span><br><span class="line">    dist = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * V</span><br><span class="line">    dist[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对所有边进行V-1次松弛操作</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> dist[edge.u] + edge.weight &lt; dist[edge.v]:</span><br><span class="line">                dist[edge.v] = dist[edge.u] + edge.weight</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查负权环</span></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> dist[edge.u] + edge.weight &lt; dist[edge.v]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;图中存在负权环&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建图</span></span><br><span class="line">edges = [</span><br><span class="line">    Edge(<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">    Edge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">    Edge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">    Edge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line">    Edge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line">    Edge(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line">    Edge(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    Edge(<span class="number">4</span>, <span class="number">3</span>, -<span class="number">3</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">V = <span class="number">5</span>  <span class="comment"># 图中顶点的数量</span></span><br><span class="line">start = <span class="number">0</span>  <span class="comment"># 源点</span></span><br><span class="line"></span><br><span class="line">distances = bellman_ford(edges, V, start)</span><br><span class="line"><span class="keyword">if</span> distances:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(V):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;到达顶点 <span class="subst">&#123;i&#125;</span> 的距离为: <span class="subst">&#123;distances[i]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="运行结果-2">运行结果</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">到达顶点 0 的距离为: 0</span><br><span class="line">到达顶点 1 的距离为: -1</span><br><span class="line">到达顶点 2 的距离为: 2</span><br><span class="line">到达顶点 3 的距离为: -2</span><br><span class="line">到达顶点 4 的距离为: 1</span><br></pre></td></tr></table></figure><h3 id="理论-2">理论</h3><h4 id="正确性-2">正确性</h4><blockquote><p>此证明包含大量盯真成分，仅供粗略理解。严谨数学证明可参考**《算法导论》第24章相关内容**</p></blockquote><p>对于最短路径：在循环的过程中，对于每条边<code>(u, v)</code>，如果<code>dist[u] + weight(u, v) &lt; dist[v]</code>，则更新<code>dist[v] = dist[u] + weight(u, v)</code>，确保了每个顶点的距离是最短路径的长度。</p><p>对于负权环：循环结束时，如果存在负权环，则在此时再进行一次遍历，仍然存在可以松弛的边。因此，如果在第V次迭代时仍然可以松弛边，则存在负权环。如果不存在负权环，则在第V次迭代后，<code>dist</code>数组将包含最短路径的长度。</p><p>因此，<strong>Bellman-Ford</strong>算法可以找到含有负权边但没有负权回路的图中的最短路径。</p><h4 id="时间复杂度-2">时间复杂度</h4><p>初始化距离数组的时间复杂度为O(V)，其中V是顶点的数量；对每条边进行V-1次松弛操作，每次操作需要遍历所有边。假设图中有E条边，则V-1次松弛操作的时间复杂度为O((V-1)*E) = O(VE)；检测负权回路需要再遍历所有边一次，时间复杂度为O(E)。</p><p>综上，<strong>Bellman-Ford</strong>算法的总时间复杂度为O(V) + O(VE) + O(E) = O(VE)。</p><h4 id="空间复杂度-2">空间复杂度</h4><p>储存距离的距离数组的空间复杂度为O(V)，其中V是顶点的数量；其他辅助变量和数据结构的空间复杂度为常量级别，可以忽略不计。得出<strong>Bellman-Ford</strong>算法的总空间复杂度为O(V)。</p><h3 id="队列优化：SPFA">队列优化：SPFA</h3><p>即 <strong>Shortest Path Faster Algorithm</strong>。</p><p>在很多时候，我们并不需要那么多无用的松弛操作。很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。</p><p>那么我们用队列来维护「哪些结点可能会引起松弛操作」，就能只访问必要的边了。</p><p><strong>SPFA</strong>也可以用于判断<code>s</code>点是否能抵达一个负环，只需记录最短路经过了多少条边，当经过了至少<code>n</code>条边时，说明<code>s</code>点可以抵达一个负环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v=<span class="number">0</span>, w=<span class="number">0</span></span>):</span><br><span class="line">        self.v = v</span><br><span class="line">        self.w = w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = [[Edge() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxn)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(maxn)]</span><br><span class="line">dis = [<span class="number">0x3F3F3F3F</span>] * maxn</span><br><span class="line">cnt = [<span class="number">0</span>] * maxn</span><br><span class="line">vis = [<span class="literal">False</span>] * maxn</span><br><span class="line"></span><br><span class="line">q = deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spfa</span>(<span class="params">n, s</span>):</span><br><span class="line">    dis[s] = <span class="number">0</span></span><br><span class="line">    vis[s] = <span class="literal">True</span></span><br><span class="line">    q.append(s)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        u = q.popleft()</span><br><span class="line">        vis[u] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> ed <span class="keyword">in</span> e[u]:</span><br><span class="line">            v, w = ed.v, ed.w</span><br><span class="line">            <span class="keyword">if</span> dis[v] &gt; dis[u] + w:</span><br><span class="line">                dis[v] = dis[u] + w</span><br><span class="line">                cnt[v] = cnt[u] + <span class="number">1</span>  <span class="comment"># 记录最短路经过的边数</span></span><br><span class="line">                <span class="keyword">if</span> cnt[v] &gt;= n:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 在不经过负环的情况下，最短路至多经过 n - 1 条边</span></span><br><span class="line">                <span class="comment"># 因此如果经过了多于 n 条边，一定说明经过了负环</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> vis[v]:</span><br><span class="line">                    q.append(v)</span><br><span class="line">                    vis[v] = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>虽然在大多数情况下<strong>SPFA</strong>跑得很快，但其最坏情况下的时间复杂度为<code>O(nm)</code>，将其卡到这个复杂度也是不难的，所以在面对可能出现特殊情况，尤其是考试时要谨慎使用（在没有负权边时最好使用<strong>Dijkstra算法</strong>，在有负权边且题目中的图没有特殊性质时，若<strong>SPFA</strong>是标算的一部分，题目不应当给出Bellman–Ford算法无法通过的数据范围)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年终总结</title>
      <link href="/2023/12/31/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2023/12/31/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 密码错误, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a57f428aaf33b3a8f7be2a272f35d99b7aeb28558a7b6e3b61688e5655198bd8">578a9066b62d8523a8d89172458a1de0083f677eaaa2c8617876a64f0711673a478e7fa81a1002ea441188a72ce3e1db673e9c84a7356ecf5524c4fe7dbcd98e9f347382536defa58947b58245ca20dfae5260420b99c2c6fa953aecdc1b857ddc48e9f51264b44982b4a491ae2fb1b6c54c10ac903c819763208ebb6ac48b08ee7e0f7f7a5e114a14f7ddc504017d8b5c3be9f5da5c3a8baa6eca63d73ad276e0b9f5e06d79c91efe14925bf4c0510ed6b62c25f297fcde9a4ea5a55406192dbd7606582a52c453d2ffbb014c35e9b9cf51fb033d1c2d93abf2513feaa01503d8a5d96fab9d498352692ad2ee0e7394022ff7f7dfabcbe4919c396e5e092c5e2d875bbaee27c030baee582cc99f9b0b44eef188bb26dcf772c3fc813f7f3ac09659eadf3298c5f691dce66345d7f5edc041a10f131e0a534151e47a0fe58c46bd36f327511a77ef9e1ff55f54fcbcbe99bf1609cf2aaf6d9f85a70a68dd69602b51d77cd50a496ee7322bd9820a719157156bb6d6defef51fd033069e131907d2c826b7f205e985451787a9fb010f9bf3c9cca414dd136b93682b02896179a1ff53fcab7f157b06b91d0b9c21a1a6a62423ad7c28826212491ad56e267050f26f4a0cd61d27a3deb0f2dc16afe660ec1fa23a3534c8285fc75d96d8b7404614a7df944552ca6059b3e1813e44cb6b7fb7024737bff1ea1f928aba47fbab3d3e047f76963f81c03b0c253ecb7ac3c1160d8beead8baf05f3fda7c25cfc149b0c4d222268362ebd21906fa315898baa7932eed0a484e8f33b848e255a92cf2ea9b1068f1f2955e6ad8694efe527348288085389cf9a13de03bdad70d0f6cb6d29cfb6b8b9a986b6056418707d47b0771694f4bc72c955d18f928cc47af3f98bf0093ee54951e62bb828f3d6df1339b2fd2b132054b08b3186eb22fd8344f40435c808432a46c8321a132d0969c33a1d93554c97c6d4ee2ee864fbfa4dac933025b005eb5a6ab7be6be8d339ef7b3e4dc2b058f58d399a54a6780c89d7bc9d9c7dcddbf650ea4a84713c8e10daf4d4b00855d483e4d8cc8ef4267159d22e4294379961a47463a38cf5d409533ac2e5edb6ac937643ba89fcaed951f02f1c46c9b91281c9fa9e85a15700c5a852dae65d605124d7ef5c07b13c762d3b86bd12193f66d095eae4e7db03eae9e3e4ce877e14a5b2ebc6c2d82ebf207ff3cac638d64e47e8df1a7e97d3a7b3508e32662bf5f5e36490258070e8451e21c928ef4c89311f04df2e4eb7e84bc25b6ea59d521171ad65bd2197506e8803476b54255e5970f200413a957307e93c6197e20e84a742d0579ee9c627dfb1de39dd663f99068783a394614b2b7e82c5c742bc52b694aa94cd661fb3f48d9a3a0c6e077bdbf6e9760132b730aa5466f1b376ffb27ecc36ca68d41d9bfd6e579fe607af6902c52ebc736786f7b9b2dc1becc368628c7955084f9e6812a4f8ad7995df08379b7a3d09da797eb5fd5dfcc7fcc261647a7e3c2e90523240f182630caca6270b0f1cad7d36ab94d3a3b9d1768ec1aaf2ceff1fc0f677a502ea9f4d94bc29e2dfa1d98a9aeb3b5c03ce34188e633527bfc405e83be5c6cf1961336842a243b3843a64694cf793297d5e768499444f4cea73478c5221396c0555a19b76c97ef2083ce1040efbd41022ac52ff27ea0ed7d89df22f44cae25e108c281ece7898e0684ff71c21d1438bcac5c70991c84e192101493e8a3865f38d32db9475599abe22c6d8a05d0017b40d59efca8e8e10b1dcde5e35336de1194b0db92c860139e439ccfeeee0f6d52d46eb47cd6a61f3963a360411787340550268eeb26785de348ca459e399082a6f464bee3934fd1cce8dfb6f6790a67e1c5606695c4fd0a48baf8da240b9b73c4318e4f10e1b12674b9a97a4edd2123cbf5e25a044ab687c77773f60698e3d97828f7889287147ec290d936a1a92bcae2d2273f3a123a6905e643ddfb165d4cb2951f4339687df13c16c3e279a61d3da4fec22390f0300793c481dac1a1a6a54d1447ff7aa29b3c0ab81ccf63fe8e7563dbda23683991ec4add2a26ae29fc3de51aea23b207669c6c629f5a6a65fe37757a5c2c42ce85e60d379d45051925846dfa6311bb60186684315d1e01b0fa6c966ebd9e070d737ae67f3fcf5ad3a9d6e08fa0059b0a1fa00caca7fcc3580952587172492da0dc28c1e92ebf24af637454b78074aa763d0a6bba454d5febfa869e7186908eb2e09d0a1506f037781306c6323378f2225509119836ddf82994cd2fd752a5fbc415c792cff6da3f93407deb0944164e664cc0d20fe2a8b9ca39d97fc2a31077174f7928d464981fe9a2bb04deddfbb0c9cfd96187fcd5565281a82d60b34604af8d5a9bdc5c50b9cdaaec30c5070bb2f3d5e6251635f497ad85a8584a6cb028f45b4fdf7ed64c30e1342d9f9a5205072d1f7a82c569eb9faf26309d6615408d7def11d5cb052a42532699a455d376ae8c0dcb251727be6d99fc3839822f00ac3fb4076bd2d3b7ee9dc54f938803ad8ad1fcc1fb60c62775f5f3a2f04d27756c6f7a3d4aec1b524b0ce7324fa95e0fbe2a766c68123e16e9fa4a24223681d15b802bc57756f679aef39cd23b2891a270363b56900f972e50d8e3ac03a49be0ea3243892caa76326d7ab515546f733e8baa7af9c9cba142528cdf1556c68cb3108017acc81f051d5689229e8c02786d400b1b5b761906457746d7272301e88cd1d28d59bf6ccd9bab6f6dc5dde9bb9f977632623b4684c38b428d736a68dc6e6f25691b96611aa47991a7610f65e74b616688f6c86d5e965941379c990c75fa1021cb8ae65ac6eacffb117446a2897885cb43d1c7c1bede32a6f45daaf36373395c4ebb362647c860d7e8b9cb00188025b2cc31a6b76b7844c961357b487d30da88562d19539e3ee73ee6276a2d6ee325c3c0747729ad8190afc68ffcc2d5d610ab1f9a0bfe0c275d7da2c65524ee8ad04f4ef427728a72a9122689e36776c0cd4744670facf52d999311843c5333d8f5fa84c8a8f38b112c2d48375641346f1ce7dfe17eedc8b10d392ff441cab3179a4957b5a520b8f4053b79b0639938bf075cb3099ec861b6e2018c5ce962dc6927167cab4f291d049767b5845597604df671aca84273970b4ff140a4dec93b0f7b292bbe2864d88a99c275873fd1e1c29a2569cf1084b54e9900a54877e0fe9ffa0a2058a49769be9069e2aecd5fd6031b6bc8f1f1b6939375e289c97895b0d5df788cdc1ef66b8af3fc1b4d0b695d5a861834eaa078fbd0f1344464b4344ff63fd0884aafd3444e4d1baf47c54d6a98218cb2af91ee9acfb4f1aefa79db5371c20317ea12b947cde70838e6a780c5c8dfd0fcc32c248a721eac7b9037e6a43b4d37b7258952042e335e58cc3a4075757c61efedfe235f3c21658b9303205397a64fdfb7c73e4388173ee4da9081b87ac7023f5ef81f20f961de008543c997f1ea6153576c9ce09955b0ce4b8a9d8c365db323febdb86f65bbae8d3ab7525dabef0b7f52a68d0671342b8ffcd9cf12cbd480396950424d2167113e4946b2ba29cc0083e4d330eb36f22a61992a4498b48827085036791ae7b7ac902429a3a7c60bec9dce6a347e022d7e89751e789422f22891326a87ae8f23229a3c2b053a9fdc9f5ee3998b11ae36a96767484089017b573fc8c1b24419185d5cf9f2efb58045ebf4b8dcb9981ed1bfeca98be632410e216148ab8f1c7e0c7ccb6f71f24854bbd3152b4a36bc5c1af66dbb02bcc837a26846d8f15cddf1e94b9c4bcd4f274e5c13cf77e75ff887893369f492a36c7698343108f396e7a6e4ed77bf1c649218b903586be9fc0b9e779674e2c4ef05f6ffe78d7def2e2939b74d267474e3987ce75614938b315112080</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多重背包</title>
      <link href="/2023/12/05/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
      <url>/2023/12/05/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1>多重背包</h1><h2 id="前言">前言</h2><blockquote><p>多重背包问题，和完全背包问题相比，其实就是每个物品可以取的数目是限定的。</p></blockquote><h2 id="一、经典多重背包">一、经典多重背包</h2><blockquote><p>有 <code>n(n ≤ 100)</code>种物品和一个容量为 <code>m(m ≤ 10000)</code> 的背包。第 i 种物品的容量是 <code>c[i]</code>，价值是 <code>w[i]</code>。现在需要选择一些物品放入背包，每种物品可以选择 <code>x[i]</code> 件，并且总容量不能超过背包容量，求能够达到的物品的最大总价值。</p></blockquote><h3 id="1、状态设计">1、状态设计</h3><p>状态<code>(i, j)</code>表示前<code>i</code>种物品恰好放入容量为<code>j</code>的背包 (0 ≤ i &lt; n，0 ≤ j ≤ m)；</p><p>令<code>dp[i][j]</code>表示状态<code>(i, j)</code>下该背包得到的最大价值，即前<code>i</code>种物品（每种物品可以选择<code>x[i]</code>件）恰好放入容量为<code>j</code>的背包所得到的最大总价值；</p><h3 id="2、状态转移方程">2、状态转移方程</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo><mtext>   </mtext><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j-c[i] \times k]+w[i] \times k) \ \ \ (0 \le k \le x[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p><p>因为每种物品有<code>x[i]</code>种可放置，将它归类为以下两种情况：</p><p>1）不放：如果 “第 i 种物品不放入容量为 j 的背包”，那么问题转化成求 <strong>“前 i-1 种物品放入容量为 j 的背包”</strong> 的问题；由于不放，所以最大价值就等于 “前 i-1 种物品放入容量为 j 的背包” 的最大价值，对应状态转移方程中<code>k = 0</code>的情况， 即<code>dp[i-1][j]</code>；</p><p>2）放 k 个：如果 “第 i 种物品放入容量为 j 的背包”，那么问题转化成求 <strong>“前 i-1 种物品放入容量为 j-c[i]*k 的背包”</strong> 的问题；那么此时最大价值就等于 “前 i-1 种物品放入容量为 j-c[i]*k 的背包” 的最大价值<strong>加上</strong>放入 k 个第 i 种物品的价值，即 <code>dp[i-1][j - c[i]*k] + w[i]*k</code>；</p><p>枚举所有满足条件的 k 就是我们所求的 “前 i 种物品恰好放入容量为 j 的背包” 的最大价值。</p><h3 id="3、对比-0-1-背包、完全背包问题">3、对比 0/1 背包、完全背包问题</h3><p>多重背包问题是背包问题的一般情况，每种物品有自己的值域限制。如果从状态转移方程出发，我们可以把三种背包问题进行归纳统一，得到一个统一的状态转移方程如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j-c[i] \times k]+w[i] \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></p><p>对于 0/1 背包问题，k 的取值为 0,1；</p><p>对于完全背包问题，k 的取值为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mrow><mo fence="true">⌊</mo><mfrac><mi>j</mi><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></mfrac><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">0,1,2,3,..., \left \lfloor \frac{j}{c[i]}  \right \rfloor </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">⌋</span></span></span></span></span></span></span></p><p>对于多重背包问题，k 的取值为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">0,1,2,3,...,x[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><h3 id="4、时间复杂度分析">4、时间复杂度分析</h3><p>对于 n 种物品放入一个容量为 m 的背包，状态数为 <code>O(nm)</code>，每次状态转移的消耗为 <code>O(x[i])</code>，所以整个状态转移的过程时间复杂度是<strong>大于</strong>O(nm) 的，那么实际是多少呢？</p><p>考虑最坏情况下，即<code>x[i] = m</code>时，那么要计算的 <code>dp[i][j]</code> 的转移数为 <code>j</code>，总的状态转移次数就是 <code>m(m+1)/2</code>，所以整个算法的时间复杂度是 <code>O(nm^2)</code> 的。</p><p>显然不够高效对吧？那接下来就是传统艺能了（）</p><h2 id="二、多重背包问题的优化">二、多重背包问题的优化</h2><h3 id="1、空间复杂度优化">1、空间复杂度优化</h3><p>一个容易想到的优化是：我们可以将每种物品拆成<code>x[i]</code>个，这样变成了</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{n}x[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>个物品的 0/1 背包问题，我们知道 0/1 背包问题优化完以后，空间复杂度只和容量有关，即 <code>O(m)</code>。</p><p>有十分甚至九分的简洁（）</p><h3 id="2、时间复杂度优化">2、时间复杂度优化</h3><p>然而， 如果这样拆分，时间复杂度还是没有变化，但是给我们提供了一个思路，就是每种物品是可以拆分的。</p><p>假设有 x[i] 个物品，我们可以按照 2 的幂进行拆分，把它拆分成：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1,2,4,...,2^{k-1},x[i]-2^{k}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>其中 k 是最大的满足 $$x[i]-2^{k}+1 \ge 0$$ 的非负整数。</p><p>这样，<code>1</code> 到 <code>x[i]</code> 之间的所有整数都能通过以上<code>k+1</code> 个数字组合出来，所以只要拆成以上 <code>k+1</code> 个物品，所有取 <code>k (0 ≤ k ≤ x[i])</code> 个物品的情况都能被考虑进来。</p><p>举例说明，当 <code>x[i] = 14</code> 时，可以拆分成 <code>1,2,4,7</code> 个物品，那么当我们要取 <code>13</code> 个这类物品的时候，相当于选择 <code>2、4、7</code>，容量分别为 <code>c[i]*2, c[i]*4, c[i]* 7</code>, 价值分别为 <code>w[i]*2, w[i]*4, w[i]*7</code>。</p><p>通过这种拆分方式，<code>x[i]</code> 最多被拆分成 <code>log x[i]</code> 个物品，然后再用 0/1 背包求解，时间复杂度如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\sum_{i=1}^{n}log_{2}x[i] )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p><p>啊~果然优化过后的就是舒服呢❤</p><h2 id="三、题目">三、题目</h2><p>这问题真不好找，在各种OJ平台找了半天没有一道经典题或直接变式，都需要夹带私货……下面这道也一样。</p><h4 id="Eden-的新背包问题-洛谷"><a href="https://www.luogu.com.cn/problem/P4095">Eden 的新背包问题 - 洛谷</a></h4><blockquote><p>失忆的 Eden 总想努力地回忆起过去，然而总是只能清晰地记得那种思念的感觉，却不能回忆起她的音容笑貌。</p><p>记忆中，她总是喜欢给 Eden 出谜题：在 valentine’s day 的夜晚，两人在闹市中闲逛时，望着礼品店里精巧玲珑的各式玩偶，她突发奇想，问了 Eden 这样的一个问题：有 <em>n</em> 个玩偶，每个玩偶有对应的价值、价钱，每个玩偶都可以被买有限次，在携带的价钱 <em>m</em> 固定的情况下，如何选择买哪些玩偶以及每个玩偶买多少个，才能使得选择的玩偶总价钱不超过 <em>m</em>，且价值和最大。</p><p>众所周知的，这是一个很经典的多重背包问题，Eden 很快解决了，不过她似乎因为自己的问题被飞快解决感到了一丝不高兴，于是她希望把问题加难：多次询问，每次询问都将给出新的总价钱，并且会去掉某个玩偶（即这个玩偶不能被选择），再问此时的多重背包的答案（即前一段所叙述的问题）。</p><p>这下 Eden 犯难了，不过 Eden 不希望自己被难住，你能帮帮他么？</p></blockquote><p>一眼丁真，这题一看显然是个<strong>多重背包二进制拆分转成01背包</strong>，即上面提到的时间复杂度优化过后的多重背包。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,c,ji,f[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> s,id;</span><br><span class="line">&#125;w[<span class="number">100000</span>],v[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123; <span class="comment">//inline 是为了优化时间哦，RTFM please~</span></span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> cw=<span class="built_in">read</span>(),cv=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(now&lt;=c)&#123;</span><br><span class="line">w[++ji].s=cw*now,v[ji].s=cv*now;</span><br><span class="line">w[ji].id=i,v[ji].id=i;</span><br><span class="line">c-=now,now*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c)&#123;</span><br><span class="line">w[++ji].s=cw*c,v[ji].s=cv*c;</span><br><span class="line">w[ji].id=i,v[ji].id=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;m;n=ji;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> l=<span class="number">1</span>;l&lt;=m;++l)&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> cn=<span class="built_in">read</span>()+<span class="number">1</span>,V=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(w[i].id!=cn)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=V;j&gt;=w[i].s;--j)&#123;</span><br><span class="line">f[j]=<span class="built_in">max</span>(f[j],f[j-w[i].s]+v[i].s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[V]);</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就<code>TLE</code>了。优化的方法很多，这里找了一位大犇的题解（官方题解页第一位）：</p><blockquote><p>我们知道背包其实就是把每一种放法都考虑一遍，我们设的状态是<strong>f[i][j]表示考虑到第i个总体积为j的最大价值</strong></p><p><strong>而我们要求的是不考虑第i种物品时的最大价值</strong></p><p>诶 这不就是<code>f[i-1][V]</code>么～～～</p><p>不对其实这样后面的物品就没有被考虑到</p><p>那怎么办呢</p><p>于是我们可以<strong>从后往前再DP一次表示从后面往前面考虑的最大价值</strong></p><p><strong>把两个背包的结果合并</strong>就是所求啦</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,c,ji;</span><br><span class="line">ll f1[<span class="number">100005</span>][<span class="number">1005</span>],f2[<span class="number">100005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;ll s;</span><br><span class="line">&#125;w[<span class="number">300005</span>],v[<span class="number">300005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> cw=<span class="built_in">read</span>(),cv=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(now&lt;=c)&#123;<span class="comment">//二进制拆分，不懂的可以记住</span></span><br><span class="line">w[++ji].s=cw*now,v[ji].s=cv*now;</span><br><span class="line">            w[ji].id=i,v[ji].id=i;</span><br><span class="line">c-=now,now*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c)&#123;</span><br><span class="line">w[++ji].s=cw*c,v[ji].s=cv*c;</span><br><span class="line">            w[ji].id=i,v[ji].id=i;</span><br><span class="line">&#125;<span class="comment">//拆分结束</span></span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">n=ji;<span class="comment">//更新物品数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//正向01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1000</span>;j++)f1[i][j]=f1[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1000</span>;j&gt;=w[i].s;j--)&#123;</span><br><span class="line">f1[i][j]=<span class="built_in">max</span>(f1[i][j],f1[i<span class="number">-1</span>][j-w[i].s]+v[i].s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;<span class="comment">//反向01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1000</span>;j++)f2[i][j]=f2[i+<span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1000</span>;j&gt;=w[i].s;j--)&#123;</span><br><span class="line">f2[i][j]=<span class="built_in">max</span>(f2[i][j],f2[i+<span class="number">1</span>][j-w[i].s]+v[i].s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line"><span class="type">int</span> cn=<span class="built_in">read</span>()+<span class="number">1</span>,V=<span class="built_in">read</span>();</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;<span class="comment">//因为同一种物品可能已被拆成多件物品而这种物品都不能被考虑于是我们要找到不包括这种物品的f1和f2</span></span><br><span class="line">        <span class="keyword">while</span>(w[l+<span class="number">1</span>].id&lt;cn&amp;&amp;l&lt;n)++l;</span><br><span class="line">        r=l;</span><br><span class="line">        <span class="keyword">while</span>(w[r+<span class="number">1</span>].id&lt;=cn&amp;&amp;r&lt;n)++r;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;<span class="comment">//这是枚举分配给该种物品之前的物品多少空间</span></span><br><span class="line">ans=<span class="built_in">max</span>(ans,f1[l][j]+f2[r+<span class="number">1</span>][V-j]);<span class="comment">//不懂的可以拿样例模拟一下，温馨提示：样例可被拆分成9件物品</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="找到了好题目可以留在评论区哦">找到了好题目可以留在评论区哦~</h6>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Knapsack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完全背包</title>
      <link href="/2023/12/04/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
      <url>/2023/12/04/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1>动态规划 之 完全背包</h1><h2 id="前言">前言</h2><blockquote><p>完全背包问题，相比 0/1背包问题，其实就是每个物品可以取无限次，就像“完全披萨”一样（无端联想）</p></blockquote><h2 id="一、完全背包𢖩莉-典例">一、完全背包<s>𢖩莉</s> 典例</h2><blockquote><p>有 <code>n(n ≤ 100)</code> 种物品和一个容量为 <code>m(m ≤ 10000)</code> 的背包。第 i 种物品的容量是 <code>c[i]</code>，价值是 <code>w[i]</code>。</p><p>现在需要选择一些物品放入背包，每种物品可以无限选择，并且总容量不能超过背包容量，求能够达到的物品的最大总价值。</p></blockquote><p>以上就是完全背包问题的完整描述，和 0/1 背包的区别单纯在于每种物品可以无限选取。</p><h3 id="1、状态设计">1、状态设计</h3><p>状态<code>(i, j)</code>表示前<code>i</code>种物品恰好放入容量为<code>j</code>的背包 (0 ≤ i &lt; n，0 ≤ j ≤ m)；</p><p>令 <code>dp[i][j]</code> 表示状态 <code>(i, j)</code> 下该背包得到的最大价值，即前<code>i</code>种物品（每种物品可以选择无限件）恰好放入容量为<code>j</code>的背包所得到的最大总价值；</p><h3 id="2、状态转移方程">2、状态转移方程</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mfrac><mi>j</mi><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j-c[i] \times k]+w[i] \times k) \ \ (0 \le k \le \frac{j}{c[i]})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2725em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p>因为每种物品有无限种可放置，将它归类为以下两种情况：</p><p>1）不放：如果 “第 i 种物品不放入容量为 j 的背包”，那么问题转化成求 <strong>“前 i-1 种物品放入容量为 j 的背包”</strong> 的问题；由于不放，所以最大价值就<strong>等于</strong> “前 i-1 种物品放入容量为 j 的背包” 的最大价值，对应状态转移方程中 k = 0 的情况， 即 <code>dp[i-1][j]</code>；</p><p>2）放 k 个：如果 “k个第 i 种物品放入容量为 j 的背包”，那么问题转化成求 <strong>“前 i-1 种物品放入容量为 j-c[i]*k 的背包”</strong> 的问题；那么此时最大价值就等于 “前 i-1 种物品放入容量为 j-c[i]*k 的背包” 的最大价值<strong>加上</strong>放入 k 个第 i 种物品的价值，即 <code>dp[i-1][j - c[i]*k] + w[i]*k</code>；</p><p>枚举所有满足条件的 k 就是我们所求的 “前 i 种物品恰好放入容量为 j 的背包” 的最大价值了。</p><h3 id="3、对比-0-1-背包问题">3、对比 0/1 背包问题</h3><p><em>完全背包问题</em>是 0/1 背包问题的扩展，区别就是它可以选择 取 0 件、取 1 件、取 2 件……取 k 件，而 <em>0/1 背包问题</em>只能取 0 件、取 1 件。如果从<strong>状态转移方程</strong>出发，我们可以把两个问题进行归纳统一，得到一个统一的状态转移方程如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j-c[i] \times k]+w[i] \times k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></p><p>对于 0/1 背包问题，k 的取值为 0, 1；</p><p>对于完全背包问题，k 的取值为 0, 1, 2, 3, … , j/c[i]；</p><h3 id="4、时间复杂度分析">4、时间复杂度分析</h3><p>对于<code>n</code>种物品放入一个容量为<code>m</code>的背包，状态数为<code> O(nm)</code>，每次状态转移的消耗为<code> O(k)</code>，所以整个状态转移的过程时间复杂度是大于<code>O(nm)</code>的，那么实际是多少呢？</p><p>考虑最坏情况下，即<code>c[i] = 1</code>时，那么要计算的 <code>dp[i][j]</code> 的转移数为 j，总的状态转移次数就是<code>m(m+1)/2</code>的，也就是说状态转移均摊时间复杂度是<code>O(m)</code>的。</p><p>这显然不够高效。有没有什么办法优化？</p><h2 id="二、完全背包问题的优化">二、完全背包问题的优化</h2><h3 id="1、时间复杂度优化">1、时间复杂度优化</h3><p>我们把状态转移方程进行展开后得到如下的 k+1 个式子：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="right center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">…</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> dp[i][j]=max\left\{\begin{array}{rcl}dp[i-1][j]       &amp;      &amp; {(1)}\\dp[i-1][j-c[i]]+w[i]     &amp;      &amp; {(2)}\\dp[i-1][j-c[i] \times 2]+w[i] \times 2     &amp;      &amp; {(3)}\\…\\dp[i-1][j-c[i] \times k]+w[i] \times k       &amp;      &amp; {(k+1)}\end{array} \right. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-1.366em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.358em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='1.216em' style='width:0.8889em' viewBox='0 0 888.89 1216' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V1216 H384z M384 0 H504 V1216 H384z'/></svg></span></span><span style="top:-3.216em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.358em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='1.216em' style='width:0.8889em' viewBox='0 0 888.89 1216' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V1216 H384z M384 0 H504 V1216 H384z'/></svg></span></span><span style="top:-5.566em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.85em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-0.45em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>利用待定系数法，用<code>j-c[i]</code>代替上式的<code>j</code>得到如下式子：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="right center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">…</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> dp[i][j-c[j]]=max\left\{\begin{array}{rcl}dp[i-1][j-c[j]]       &amp;      &amp; {(1)}\\dp[i-1][j-c[i] \times 2]+w[i]     &amp;      &amp; {(2)}\\dp[i-1][j-c[i] \times 3]+w[i] \times 2     &amp;      &amp; {(3)}\\…\\dp[i-1][j-c[i] \times k]+w[i] \times (k-1)       &amp;      &amp; {(k)}\end{array} \right. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-1.366em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.358em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='1.216em' style='width:0.8889em' viewBox='0 0 888.89 1216' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V1216 H384z M384 0 H504 V1216 H384z'/></svg></span></span><span style="top:-3.216em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.358em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='1.216em' style='width:0.8889em' viewBox='0 0 888.89 1216' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V1216 H384z M384 0 H504 V1216 H384z'/></svg></span></span><span style="top:-5.566em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]]</span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.85em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-0.45em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>等式两边都加上<code> w[i]</code> 得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="right center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">…</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mi>k</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> dp[i][j-c[j]]+w[i]=max\left\{\begin{array}{rcl}dp[i-1][j-c[j]]+w[i]      &amp;      &amp; {(1)}\\dp[i-1][j-c[i] \times 2]+w[i] \times 2    &amp;      &amp; {(2)}\\dp[i-1][j-c[i] \times 3]+w[i] \times 3     &amp;      &amp; {(3)}\\…\\dp[i-1][j-c[i] \times k]+w[i] \times k       &amp;      &amp; {(k)}\end{array} \right. </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-1.366em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.358em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='1.216em' style='width:0.8889em' viewBox='0 0 888.89 1216' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V1216 H384z M384 0 H504 V1216 H384z'/></svg></span></span><span style="top:-3.216em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.358em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='1.216em' style='width:0.8889em' viewBox='0 0 888.89 1216' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V1216 H384z M384 0 H504 V1216 H384z'/></svg></span></span><span style="top:-5.566em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">3</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.85em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-0.45em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>于是我们发现，这里的 (1)…(k) 式子等价于最开始的状态转移方程中的 (2) … (k+1) 式，所以原状态转移方程可以简化为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j]+w[i],dp[i][j-c[i]]+w[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p><p>这样就把原本均摊时间复杂度为<code>O(m)</code>的状态转移优化到了<code> O(1)</code>。</p><p>那么我们来理解一下这个状态转移方程的含义：</p><p>对于第<code>i</code>种物品，其实只有两种选择：一个都不放、至少放一个；一个都不放 就是 <strong>“前 i-1 种物品放满一个容量为 j 的背包”</strong> 的情况，即<code> dp[i-1][j]</code>；至少放一个 的话，我们尝试在 <em>“前 i 种物品放满一个容量为 j 的背包”</em> 里**拿掉 **1 个物品，即 <strong>“前 i 种物品放满一个容量为<code>j-c[i]</code>的背包”</strong>，这时候的值就是<code> dp[i][j-c[i]] + w[i]</code>。取两者的大者就是答案了。</p><p>这也是完全背包问题的一种比较容易理解的思路。这也告诉我们，每一种&quot;一眼丁真&quot;成立的方法背后都是有严格推导支撑的。有些时候直觉并不靠谱，数学证明才是硬通货（）。</p><h3 id="2、空间复杂度优化">2、空间复杂度优化</h3><p>因为当前行的状态的值只依赖于上一行和当前行的状态，和上上一行、上上上一行的状态无关，所以可以利用滚动数组记录上一行和当前行的状态，将上一行和当前行的状态进行滚动计算（自己去找啦，都已经能到这一步了，不要总是想着一篇文章解决，才不是因为我写了半天把自己绕晕了）。</p><p>根据优化后的状态转移方程，我们发现只需要保留一行状态，按照<code>j</code>递增进行顺序计算，就可以忽略<code>i</code>，做到把二维的问题转换成一维，将状态转移方程变成如下表示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[j]=max(dp[j],dp[j-c[i]]+w[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p><p>肥肠的完美，直接把二维的问题转换成了一维的了。我们称之为高效（）。</p><h2 id="三、练习时间！">三、练习时间！</h2><h4 id="面试题-08-11-硬币-力扣（LeetCode）"><a href="https://leetcode.cn/problems/coin-lcci/description/">面试题 08.11. 硬币 - 力扣（LeetCode）</a></h4><blockquote><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算<code>n</code>分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p></blockquote><p>经典老番嗷，谁还没有被这道题目折磨过的自觉去体验一把再回来。</p><p>(虽然这道题目不用动态规划也能写，不过我记得我当时用的是<code>Python</code>走的捷径……)</p><p>这道题的思路跟上面的基本一样，把有关条件替换掉就好了。<s>（萝莉の至高力）</s></p><blockquote><p>有 <code>4</code> 种物品和一个容量为 <code>n</code> 的背包。每种物品的容量分别是 <code>25、10、5、1</code>。</p><p>选择一些物品放入背包，每种物品可以无限选择，并且总容量不能超过背包容量，求有多少种装法。</p></blockquote><p>话不多说，上代码！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">waysToChange</span><span class="params">(<span class="type">int</span> n)</span>&#123; <span class="comment">//成熟的人会自己脑补注释（实在不行交给GPT嘛）</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000001</span>];</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = b[i]; j &lt;= n; ++j) &#123;</span><br><span class="line">            dp[j] = (dp[j] + dp[j - b[i]]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="322-零钱兑换-力扣（LeetCode）"><a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换 - 力扣（LeetCode）</a></h4><p>和上一题其实差不多，转换一下数组的定义就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>* coins, <span class="type">int</span> coinsSize, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">10001</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10001</span>; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">10000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; coinsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j - coins[i]] + <span class="number">1</span> &lt; dp[j]) &#123;</span><br><span class="line">                dp[j] = dp[j - coins[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == <span class="number">10000000</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Knapsack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包</title>
      <link href="/2023/12/03/01%E8%83%8C%E5%8C%85/"/>
      <url>/2023/12/03/01%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1>动规入门：0/1背包</h1><h2 id="前言">前言</h2><blockquote><p>0/1 背包问题，作为动态规划问题的经典问题，可以帮助捋顺思维。之所以叫0/1背包，是因为在这类问题中每种物品只有一个，每个物品只有放和不放两种选择，即对于一种物品，可以表示为0和1两种状态。因此0/1背包统计的是 <strong>恒定容量</strong> 储存数个 <strong>不同物品</strong> 的 <strong>最大价值</strong>。核心在于确认好<strong>初始状态</strong>、<strong>递推基数</strong>和<strong>递推增量</strong>（反正就是<code>dp[i][j-?] + ?</code>，理解万岁）。说白了主要难点还是在确认递推关系上。</p></blockquote><h2 id="一、经典0-1背包问题">一、经典0/1背包问题</h2><blockquote><p>有 n(n ≤ 100) 个物品和一个容量为 m(m ≤ 10000) 的背包。</p><p>第 i 个物品的容量是 c[i]，价值是 w[i]。现在需要选择一些物品放入背包，并且总容量不能超过背包容量，求能够达到的物品的最大总价值。</p></blockquote><h3 id="1、状态设计">1、状态设计</h3><p><strong>动态规划的最核心之一是确认好dp数组的含义</strong>。这决定了你接下来的递推关系和最终问题的返回值。（不知道为什么叫dp数组的自己去查动态规划的英文）每次当你找递推关系出现问题的时候，最好的方法就是回头看一下你确认的dp数组的含义。如果实在找不出，那就要考虑是否在这最开始就出现了问题。</p><p>在01背包问题中，我们一般情况下这么设定dp数组：</p><p>根据题目要求，我们很容易想到用一对数<code>(i, j)</code>表示前 <code>i</code> 个物品恰好放入容量为 <code>j</code> 的背包<code> (0 ≤ i &lt; n，0 ≤ j ≤ m)</code>；</p><p>因此我们的数组 <code>dp[i][j]</code> 表示状态 <code>(i, j)</code> 下该背包得到的最大价值，即前 <code>i</code> 个物品恰好放入容量为 <code>j</code> 的背包所得到的最大总价值；</p><h3 id="2、状态转移方程">2、状态转移方程</h3><p>列出状态转移方程如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = max(dp[i-1][j], dp[i-1][j - c[i]] + w[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p><p>假设前<code>i-1</code>个物品已经统计完毕，现在正在统计第<code>i</code>个物品的情况。因为每个物品要么放，要么不放，所以只需要考虑两种情况：</p><p>1）不放：如果 <strong>“第 i 个物品不放入容量为 j 的背包”</strong>，那么问题转化成求 <strong>“前 i-1 个物品放入容量为 j 的背包”</strong> 的问题；由于不放，所以最大价值就等于 “前 i-1 个物品放入容量为 j 的背包” 的最大价值，即 <code>dp[i-1][j]</code>；</p><p>2）放：如果 <strong>“第 i 个物品放入容量为 j 的背包”</strong>，那么问题转化成求 <strong>“前 i-1 个物品放入容量为 j-c[i] 的背包”</strong> 的问题；那么此时最大价值就等于 <strong>“前 i-1 个物品放入容量为 j-c[i] 的背包”</strong> 的最大价值，加上<strong>放入第 i 个物品的价值</strong>，即 <code>dp[i-1][j - c[i]] + w[i]</code></p><p>将以上两种情况取大者，就是我们所求的 <strong>“前 i 个物品恰好放入容量为 j 的背包”</strong> 的最大价值了。</p><p>我知道可能有点绕，这种时候就要请你回去看一下上面<a href="https://aullchen.github.io/2023/12/03/01%E8%83%8C%E5%8C%85/#1%E3%80%81%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1">状态设计</a>里的内容了。</p><h3 id="3、初始状态">3、初始状态</h3><p>既然使用递推关系解决问题，<strong>初始状态的正误直接影响了整个问题的正误</strong>。</p><p>在这个01背包问题中，我们发现，当状态在进行转移的时候，<code>(i, j)</code> 不是来自 <code>(i-1, j)</code>，就是来自 <code>(i-1, j - c[i])</code>，所以必然有一个初始状态，而这个初始状态就是 <code>(0, 0)</code>，含义是 <strong>“前 0 个物品放入一个背包容量为 0 的背包”</strong>，这个状态下的最大价值为 <code>0</code>，即 <code>dp[0][0] = 0</code>；后续的状态都可以由它递推得出，你可以手动推一下试试就明白了。</p><p>我知道可能有点绕，这种时候就要请你回去看一下上面<a href="https://aullchen.github.io/2023/12/03/01%E8%83%8C%E5%8C%85/#1%E3%80%81%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1">状态设计</a>里的内容了。（梅开二度）</p><h3 id="4、非法状态">4、非法状态</h3><p>那么我们再来考虑，如果出现了 (0, 3) ，这是什么意思呢？它代表的是 <strong>“前 0 个物品恰好放入一个背包容量为 3 的背包”</strong>，明显这种情况是不存在的，因为 0 个物品的价值肯定是 0。所以这种状态被称为非法状态，<strong>非法状态是无法进行状态转移的</strong>。我们需要对他们也进行初始化。</p><p>我知道可能有点绕，这种时候就要请你回去看一下上面<a href="https://aullchen.github.io/2023/12/03/01%E8%83%8C%E5%8C%85/#1%E3%80%81%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1">状态设计</a>里的内容了。（帽子戏法）</p><h3 id="5、状态初始化">5、状态初始化</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mstyle scriptlevel="0" displaystyle="false"><mi>i</mi></mstyle><mtext>=0</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mstyle scriptlevel="0" displaystyle="false"><mi>i</mi></mstyle><mtext>&gt;0</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[0][i]=\left\{\begin{aligned}0&amp;&amp;\text{$i$=0}\\x &amp;&amp;\text{$i$&gt;0}\\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord mathnormal">i</span><span class="mord">=0</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord mathnormal">i</span><span class="mord">&gt;0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中 <code>x</code> 在程序实现时，我们可以设定一个非常小的数，比如 <code>-1000000000</code>，只要保证无论如何状态转移它都不能成为最优解的候选状态即可。</p><h2 id="二、练习">二、练习</h2><h3 id="变形题：416-分割等和子集-力扣（LeetCode）">变形题：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集 - 力扣（LeetCode）</a></h3><blockquote><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p></blockquote><h5 id="分析">分析</h5><p>这道题可以换一种表述：给定一个只包含正整数的非空数组<code>nums[]</code>，判断是否可以从数组中选出一些数字，使得这些数字的和等于整个数组的元素和的一半。这个问题可以转换成「01 背包问题」。</p><p>与传统的「01 背包问题」的区别在于，传统的「01 背包问题」要求选取的物品的重量之和不能超过背包的总容量，这道题则要求选取的数字的和恰好等于整个数组的元素和的一半。类似于传统的「01 背包问题」，可以使用动态规划求解。</p><p>在使用动态规划求解之前，首先需要根据数组的长度 <code>n</code> 判断数组是否可以被划分。如果 <code>n&lt;2</code>，则不可能将数组分割成元素和相等的两个子集，因此直接返回 <code>false</code>。其次判断数组元素的和是不是奇数，此时也不可能平分。</p><p>由于我们的目的是得知目标是否存在，因此dp数组记录的应该是对于前<code>i</code>个物品，能否组合出和为<code>sum</code>的结果。可以为1，不可以则为0。此时的初始情况如下：</p><ol><li><p>如果不选取任何正整数，则被选取的正整数等于 0。因此对于所有<code> 0≤i&lt;n</code>，都有<code> dp[i][0]=true</code>。</p></li><li><p>当 <code>i==0</code> 时，只有一个正整数 <code>nums[0]</code> 可以被选取，因此<code> dp[0][nums[0]]=true</code>。</p></li></ol><p>状态转移方程为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mstyle scriptlevel="0" displaystyle="false"><mi>j</mi></mstyle><mtext>≥nums[i]</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mstyle scriptlevel="0" displaystyle="false"><mi>j</mi></mstyle><mtext>&lt;nums[i]</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j]=\left\{\begin{aligned}dp[i-1][j]|dp[i-1][j-nums[i]]&amp;&amp;\text{$j$≥nums[i]}\\dp[i-1][j] &amp;&amp;\text{$j$&lt;nums[i]}\\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord">∣</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">≥nums[i]</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">&lt;nums[i]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>这里出现了一个位运算符<strong>或</strong><code>|</code>，不需要我搓个表格告诉你他的作用吧？</p><p>想想为什么是这样？（<a href="https://aullchen.github.io/2023/12/03/01%E8%83%8C%E5%8C%85/#1%E3%80%81%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1">你知道我要说什么.jpg</a>）</p><p>根据dp数组的定义，我们可以得知<code>dp[numsSize-1][sum/2]</code>的存在与否就是我们要求的解。</p><h5 id="源码">源码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">201</span>][<span class="number">20001</span>], sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>( j - nums[i] &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                dp[i][j] |= dp[i<span class="number">-1</span>][j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[numsSize<span class="number">-1</span>][sum/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1262-可被三整除的最大和-力扣（LeetCode）"><a href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/">1262. 可被三整除的最大和 - 力扣（LeetCode）</a></h3><p>自己动脑筋吧~（提示一下，同余理论很好用哦！）</p><p>要是真的不会，你已经是一个成熟的CSer了，要学会自己寻找答案哦~</p><p>本蒟蒻の代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSumDivThree</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">40001</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>]%<span class="number">3</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="type">int</span> p = ((j - nums[i]%<span class="number">3</span>) + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][p] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][p] + nums[i] &gt; dp[i][j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][p] + nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[numsSize<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Knapsack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo某些分类或标签页出现404</title>
      <link href="/2023/12/02/hexo%E6%9F%90%E4%BA%9B%E5%88%86%E7%B1%BB%E6%88%96%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%87%BA%E7%8E%B0404/"/>
      <url>/2023/12/02/hexo%E6%9F%90%E4%BA%9B%E5%88%86%E7%B1%BB%E6%88%96%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%87%BA%E7%8E%B0404/</url>
      
        <content type="html"><![CDATA[<p>博客文章多了，某天突然发现，有一个tag点进去404，在本地运行<code>hexo s</code>却正常没有问题。</p><p>首先是老传统<code>STFW</code>，但是网络上的相关内容却都是解决tags总页面404的，我却是单独的tag页面丢失，没找到我想要的内容。用实力证明搜索引擎不可靠（笑）。刚好那段时间比较忙，就暂且把这事搁置了。（反正博客也没什么人看）</p><p>中间有一天突发奇想，把链接里相关tag的大写改为小写，发现可以访问了。没时间去解决（懒狗不想手动修改每一个tag），于是在Tags页面下写了条评论。</p><p>今天闲下来突然想起还有这事。搜索引擎一如既往稳定发挥。怎么办呢？不急，我还有一招——<code>RTFM</code>。找到hexo在Github上的仓库，在<code>Issues</code>里面寻找。果然找到了老前辈的馈赠——<a href="https://github.com/hexojs/hexo/issues/818">BUG反馈：大写开头的标签出现404 · Issue #818 · hexojs/hexo (github.com)</a></p><p>在里面逛了一圈发现是因为git中设置了大小写不敏感。</p><h2 id="解决过程">解决过程</h2><p>在网上查找修改 git 设置不忽略大小写的方法。（顺便看到了很多因为这个引发的“事故”哈哈）</p><p>进入博客文件夹的 git 目录：<code>.deploy_git</code>，修改 <code>.git </code>文件夹中的配置文件<code> config</code>，将<code>ignorecase=true</code> 改为<code> ignorecase=false</code></p><p>清空并重新部署博客。</p><p>发现还没有解决，查找到方案：清空部署到 github 上的文件，重新发布：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd .deploy_git</span><br><span class="line">git rm -rf *</span><br><span class="line">git commit -m &#x27;clean all file&#x27;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>在运行<code>git push</code>时报错，显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">fatal: The upstream branch of your current branch does not match</span><br><span class="line">the name of your current branch.  To push to the upstream branch</span><br><span class="line">on the remote, use</span><br><span class="line"></span><br><span class="line">    git push git@github.com:AullChen/AullChen.github.io.git HEAD:main</span><br><span class="line"></span><br><span class="line">To push to the branch of the same name on the remote, use</span><br><span class="line"></span><br><span class="line">    git push git@github.com:AullChen/AullChen.github.io.git HEAD</span><br><span class="line"></span><br><span class="line">To choose either option permanently, see push.default in &#x27;git help config&#x27;.</span><br><span class="line"></span><br><span class="line">To avoid automatically configuring an upstream branch when its name</span><br><span class="line">won&#x27;t match the local branch, see option &#x27;simple&#x27; of branch.autoSetupMerge</span><br><span class="line">in &#x27;git help config&#x27;.</span><br></pre></td></tr></table></figure><p>按其提示选择第二个<code>git push git@github.com:AullChen/AullChen.github.io.git HEAD</code>部署到远程仓库。</p><p>进入博客文件夹，用 hexo 重新生成部署</p><p><code>hexo clean &amp;&amp; hexo g -d</code></p><p>问题完美解决！</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分枚举</title>
      <link href="/2023/12/02/%E4%BA%8C%E5%88%86%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/12/02/%E4%BA%8C%E5%88%86%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1>二分枚举</h1><h2 id="前言">前言</h2><blockquote><p>二分查找的问题可以理解如下：在一个序列上，某个特定的标记将其分成左右两个部分。我们需要找到这个标记的位置在哪两个元素中间。当然，我们实际需要的显然不是这个标记，而是挨着标记的元素，因此二分查找一个需要特别注意的地方就是选取标记左边还是右边的元素返回。一个需要查找的序列可以抽象成下面的形状：(确实很抽象)</p><p>□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□^□□□□□□□□□□□□□□□□□□□□□□□□□□□</p><p>□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□^</p><p>^□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□</p></blockquote><h2 id="一、线性枚举">一、线性枚举</h2><h3 id="1、定义">1、定义</h3><p>线性枚举指的就是遍历某个顺序表（如一维数组）的所有元素，找到满足条件的那个元素并且返回，返回值可以是下标，也可以是元素本身。</p><p>由于是遍历的，穷举了所有情况，所以一定是可以找到解的，一些资料上也称之为 <code>暴力算法 （Brute Force）</code>。</p><h3 id="2、时间复杂度">2、时间复杂度</h3><p>线性枚举就是无脑遍历所有情况，并且在满足条件的第一时间退出循环。因此，当数组长度为 n 时，算法的时间复杂度为<code> O(n)</code>，比较低效，我们需要更加高效的算法。（P社玩家特有的对*“高效”*的大力追求）</p><h2 id="二、二分枚举">二、二分枚举</h2><h3 id="1、定义-2">1、定义</h3><p>二分枚举，也叫二分查找，指的就是给定<strong>一个区间</strong>，每次选择区间的<strong>中点</strong>，并且判断区间中点是否满足<strong>某个条件</strong>，从而选择左区间继续求解还是右区间继续求解，直到区间长度不能再切分为止。</p><p>由于每次都是把区间折半，又叫折半查找，时间复杂度为 <code>O(logn)</code>，和线性枚举的求解结果一致，但是高效许多，返回值可以是下标，也可以是元素本身。</p><h3 id="2、举例说明">2、举例说明</h3><blockquote><p>一个有序数组<code>arr[]</code>，要求找到元素<code>3</code>的位置。</p><p><code>[0,1,2,3,4,5,6,7,8,9]</code></p></blockquote><h3 id="3、算法分析">3、算法分析</h3><h4 id="1）目标">1）目标</h4><p>找到特定元素的位置，由于解题之前我们不清楚数据大小和具体位置，为了提高效率的期望值，使用二分枚举是较好的选择。根据二分枚举的定义，一共有三个重点：<strong>区间、中点、条件</strong>。</p><h4 id="2）区间框定">2）区间框定</h4><p>利用线性枚举的思路，我们引入游标的概念，只不过需要两个游标，左边一个右边一个，两者中间的区域就是我们框定的查找区间。为了包涵查找元素在头尾的情况，我们把游标初始位置都设置在数组以外。即对于一个<code>n</code>个元素的数组，左游标初始位置在<code>-1</code>，右游标初始位置在<code>n</code>。当然，如果你确定该元素不在两头了，也可以将左游标初始位置在<code>0</code>，右游标初始位置在<code>n-1</code>。这只需要先多一步头尾判断，好处是不容易出现越界。</p><blockquote><p><code>[0,1,2,3,4,5,6,7,8,9]</code></p><p>↑———————————↑   （这里打——的原因是<code>hexo</code>渲染的时候会吞掉空格，——只是为了把↑放到正确的位置上。）</p></blockquote><h4 id="3）选择中点">3）选择中点</h4><p>我们将两个游标位置的差除以2，结果四舍五入取整，再加上原本左边游标的位置，从而得到两个游标的中点。注意，这一<strong>中点</strong>不一定正好就是两个游标正中间的位置，因为元素个数不一定是奇数。这只是对真正中点的一种靠近。</p><blockquote><p><code>[0,1,2,3,4,5,6,7,8,9]</code></p><p>↑———–—↑————–—↑</p></blockquote><h4 id="4）条件判断">4）条件判断</h4><p>判断的条件，我们可以理解为<strong>前言</strong>提到的<strong>标记</strong>。标记不在序列上（因为只是一个判断函数），将序列分成两部分，目标与其紧邻。</p><p>在这个有序数组中，判断的方式就是和<code>3</code>比较大小。如果大于3，则证明中点在目标的右边。否则在左边。在我们的例子中，4&gt;3，因此中点在3的右边。此时我们需要做的就是将右端点重置在中点的位置。这样就完成了一次二分，区间相比之前，缩小了一半。注意，我们要求的解，一定永远在 <strong>左游标</strong> 和 <strong>右游标</strong> 之间。</p><blockquote><p><code>[0,1,2,3,4,5,6,7,8,9]</code></p><p>↑—–———↑</p></blockquote><p>然后，我们继续选取游标的中点，并且判断中点的条件，进行重复操作，直到左右游标的位置差为1。此时无法继续进行二分，程序停止。</p><blockquote><p><code>[0,1,2,3,4,5,6,7,8,9]</code></p><p>↑—-—↑–—↑</p><p><code>[0,1,2,3,4,5,6,7,8,9]</code></p><p>------—↑–—↑</p><p><code>[0,1,2,3,4,5,6,7,8,9]</code></p><p>———↑ -↑- ↑</p><p><code>[0,1,2,3,4,5,6,7,8,9]</code></p><p>————↑ -↑</p></blockquote><p>此时左游标的位置就是我们这个问题要求的解。</p><p>当然，如果选取条件改变，也有可能最终的游标指向2、3，此时右游标的位置才是我们寻求的解。因此左右游标的选择需要根据条件判定的标准进行。</p><p>这个时候，这个时候 <strong>红色游标</strong> 和 <strong>绿色游标</strong> 的位置一定相差 1，并且 <strong>绿色游标</strong> 的位置就是我们这个问题要求的解。</p><h3 id="4、源码详解">4、源码详解</h3><h4 id="1）条件判定">1）条件判定</h4><p>判断一个元素在目标左还是右，我们可以单独用一个函数来实现。C语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isRight</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> x)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>val &gt; 3</code>是一个判断语句，因此最后返回的结果将是<code>0</code>（不成立）或<code>1</code>（成立）。</p><h4 id="2）二分枚举模板">2）二分枚举模板</h4><p>接下来的二分枚举模板可以解决大部分二分枚举的问题，请妥善保管。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize, <span class="type">int</span> x)</span> &#123; <span class="comment">//(0)</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>, r = arrSize; <span class="comment">// (1)</span></span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1</span>) &#123; <span class="comment">// (2)</span></span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>; <span class="comment">// (3)</span></span><br><span class="line">        <span class="keyword">if</span>( isRight(arr[mid], x) ) <span class="comment">// (4)</span></span><br><span class="line">        r = mid; <span class="comment">// (5)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        l = mid; <span class="comment">// (6)</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> l; <span class="comment">// (7)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(0) <code>x</code>是查找的目标元素；</p><p>(1) <code>l</code> 代表 <strong>左游标</strong>，<code>r</code> 代表 <strong>右游标</strong>；</p><p>(2) 当区间长度大于<code>2</code>的时候，二分缩小区间，这一步被称为 <em>区间收敛</em>；</p><p>(3) <code>mid</code>为计算出来的区间 [l, r] 的中点；</p><p>(4) 判断区间中点对应的元素符不符合条件；</p><p>(5) 如果符合，证明中点在目标元素右边(不然为什么叫<code>isRight</code>)，把<strong>右游标</strong>用<strong>中点游标</strong>替换。</p><p>(5) 如果 <strong>中点元素</strong> 是 <strong>绿色</strong>，则从 <strong>中点</strong> 到 <em>r</em> 的值都为 <strong>绿色</strong>，用 <strong>中点</strong> 替换 <strong>绿色游标</strong>；</p><p>(6) 如果不符合，证明中点在目标元素左边，把<strong>左游标</strong>用<strong>中点游标</strong>替换。</p><p>(7) 这个地方是模板需要变通的地方，如果目标在左游标处，那么应该返回<code>l</code>；反之，如果目标在右游标处，则应该返回<code>r</code>。这里是前者。</p><p>这由你的判断函数决定。<strong>无法判断的时候，可以将目标结果代入函数，看看函数是否成立，从而判断是左是右。</strong></p><h2 id="三、练习">三、练习</h2><ol><li><h4 id="P1571-眼红的Medusa-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1571">P1571 眼红的Medusa - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k[<span class="number">100010</span>] = &#123;<span class="number">0</span>&#125;, t[<span class="number">100010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isRight</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> *a, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[idx] &gt; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isRight</span>(mid, a, t))</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">binarySearch</span>(<span class="number">0</span>, numsSize - <span class="number">1</span>, nums, target);</span><br><span class="line">    <span class="keyword">if</span> (nums[numsSize - <span class="number">1</span>] == target) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[numsSize - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[a] == target) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[a]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">qsort</span>(t, m, <span class="built_in">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">search</span>(t, m, k[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><h4 id="704-二分查找-力扣（LeetCode）"><a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></h4></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isRight</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> *a, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[idx] &gt; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( isRight(mid, a, t) ) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = binarySearch(<span class="number">0</span>, numsSize<span class="number">-1</span>, nums, target);</span><br><span class="line">    <span class="keyword">if</span>(nums[numsSize<span class="number">-1</span>] == target) <span class="keyword">return</span> numsSize<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[a] == target) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><h4 id="1351-统计有序矩阵中的负数-力扣（LeetCode）"><a href="https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/description/">1351. 统计有序矩阵中的负数 - 力扣（LeetCode）</a></h4></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isRight</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> *a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[idx] &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *a)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( isRight(mid, a) ) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">countNegatives</span><span class="params">(<span class="type">int</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = gridSize;</span><br><span class="line">    <span class="type">int</span> n = gridColSize[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cnt += ( n - binarySearch(<span class="number">-1</span>, n, grid[i]) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/11/20/%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/11/20/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>链表</h1><blockquote><p>本文语法涉及大量C语言中结构体的语法，请在食用前确保已经有所了解，不然可能会一头雾水。</p><p>当然，如果实在不懂，可以留言。</p></blockquote><h1>一、链表的概念</h1><p>对于顺序存储的结构，最大的缺点就是 <strong>插入</strong> 和 <strong>删除</strong> 的时候需要移动大量的元素。所以基于前人的智慧，他们发明了链表。</p><h2 id="1、链表的定义">1、链表的定义</h2><p>链表由一个个结点组成，每个结点之间通过链接关系串联起来，每个结点都有一个后继结点，最后一个结点的后继结点为空结点。</p><p>由链接关系 A -&gt; B组织起来的两个结点，B 被称为 A 的后继结点，A 被称为 B 的前驱结点。</p><p>链表分为单向链表、双向链表、循环链表等等。</p><p>本文介绍单向链表。</p><h2 id="2、链表结点的定义">2、链表结点的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    DataType data; <span class="comment">// (1)</span></span><br><span class="line">    ListNode *next; <span class="comment">// (2)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（1）<code>data</code> 是数据域，用来储存数据，可以是任意类型，由编码的人自行指定其<code>DataType</code>。本文数据域全部采用<code>int</code>型进行讲解。</p><p>（2）<code>*next</code>是指针域，指向 <strong>后继结点</strong> 的地址。</p><h2 id="3、链表结点创建">3、链表结点创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">ListCreateNode</span><span class="params">(DataType data)</span> &#123;</span><br><span class="line">    ListNode *node = (ListNode *) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span>(ListNode) ); <span class="comment">// (1)</span></span><br><span class="line">    node-&gt;data = data; <span class="comment">// (2)</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>; <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> node; <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）利用系统库函数 <code>malloc</code>分配一块内存空间用来存放 <code>ListNode</code> ，即链表结点对象。</p><p>（2）将数据域置为函数传参data</p><p>（3）将指针域置空，代表这是一个孤立的 <strong>链表结点</strong>，即没有后继节点。</p><p>（4）最后返回这个结点的指针</p><h2 id="4、虚拟头结点">4、虚拟头结点</h2><p>为了方便对链表执行操作，往往会建立一个虚拟头结点。这个头结点上不存储数据，也就是 <code>data</code>字段为一个特殊的标识（例如 -1）。可以采用链表结点创建来生成一个虚拟头结点实例。</p><p><code>ListNode *head = ListCreateNode(-1);</code></p><h1>二、链表的遍历</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListTraversal</span><span class="params">(ListNode *head)</span> &#123;</span><br><span class="line">    ListNode *tmp = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">        <span class="comment">// 为所欲为</span></span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ListTraversal</code>代表对链表进行遍历。首先从头结点开始缓存到 <code>tmp</code> 中，继续循环访问 <code>tmp</code>的后继结点，直到链表的最后一个结点为止。在访问的过程中可以执行你需要的操作。</p><h1>三、链表的调试</h1><h2 id="1、含义">1、含义</h2><p>调试就是通过一些可视化的方式最终将链表打印出来。一般利用遍历的方式实现。</p><h2 id="2、源码">2、源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListPrint</span><span class="params">(ListNode *head)</span> &#123;</span><br><span class="line">    ListNode *tmp = head-&gt;next;</span><br><span class="line">    print(<span class="string">&quot;H -&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, tmp-&gt;data);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先把虚拟头结点用 <code>H</code>表示并打印出来。然后遍历整个链表，遍历的过程中利用格式化打印出结点的值，再跟上一个 <code>-&gt;</code>，最后在打印一个 <code>NULL</code>。这样一个链表就打印出来了</p><h1>四、链表结点的索引</h1><h2 id="1、含义-2">1、含义</h2><p>链表结点的索引就是给定一个链表头和一个下标<code>i</code>，通过下标获取到链表的第 <code>i </code>个元素。</p><h2 id="2、源码-2">2、源码</h2>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">ListGetNode</span><span class="params">(ListNode *head, <span class="type">int</span> i)</span> &#123;<span class="comment">//(1)</span></span><br><span class="line">    ListNode *tmp = head;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">while</span>(tmp &amp;&amp; j &lt; i) &#123;<span class="comment">//(3)</span></span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tmp) &#123;<span class="comment">//(4)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;<span class="comment">//(5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）<code>tmp</code> 代表从链表头开始的 <strong>游标指针</strong>，用于对链表进行 <strong>遍历</strong> 操作。</p><p>（2）<code>j</code> 代表当前访问到了第 <code>j</code> 个结点。</p><p>（3）如果 <strong>游标指针</strong> 非空 并且<code> j &lt; i</code>，则代表还没访问到目标结点，继续执行循环，将 游标 的 <strong>后继结点</strong> 作为新一轮的 <strong>游标指针</strong>继续迭代。<code>j</code> 自增等价于将 <code>j + 1</code> 赋值给 <code>j</code>。</p><p>（4）当 <strong>游标指针</strong> 为空，则说明给定的<code>i</code>超过了链表长度，返回 <strong>空结点</strong>。</p><p>（5）最后返回找到的第 <code>i </code>个结点。</p><h1>五、链表结点的插入</h1><h2 id="1、含义-3">1、含义</h2><p>给定一个链表头和一个位置<code> i (i &gt;= 0)</code>和一个值 <code>data</code>，生成一个值为 <code>data</code> 的结点，并且将它插入到链表第 <code>i</code> 个结点之后的位置。</p><h2 id="2、源码-3">2、源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">ListInsertNode</span><span class="params">(ListNode *head, <span class="type">int</span> i, DataType v)</span> &#123;</span><br><span class="line">    ListNode *pre, *vtx, *aft;<span class="comment">//(1)</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//(2)</span></span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="keyword">while</span>(pre &amp;&amp; j &lt; i) &#123;<span class="comment">//(3)</span></span><br><span class="line">        pre = pre-&gt;next;<span class="comment">//(4)</span></span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!pre) &#123;<span class="comment">//(5)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vtx = ListCreateNode(v);<span class="comment">//(6)</span></span><br><span class="line">    aft = pre-&gt;next;</span><br><span class="line">    vtx-&gt;next = aft;</span><br><span class="line">    pre-&gt;next = vtx;</span><br><span class="line">    <span class="keyword">return</span> vtx;<span class="comment">//(7)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）预先定义三个指针，当结点插入完毕后<code> pre -&gt; vtx -&gt; aft</code>。</p><p>（2）定义一个计数器，当 <code>j == i</code> 时表明找到要插入的位置。</p><p>（3）从 链表虚拟头结点 开始，迭代遍历链表，如果还没有到链表尾或者没有找到插入位置，则继续循环。</p><p>（4）将 <strong>游标指针</strong> 的 <strong>后继结点</strong>作为新一轮的 <strong>游标指针</strong> 继续迭代，计数器<code>j</code>自增 <code>1</code>。</p><p>（5）元素个数不足，无法找到给定位置 返回 <code>NULL</code>。</p><p>（6）创建一个值为<code>v</code>的 <strong>孤立结点</strong>，将<code>vtx</code>插入到<code>pre -&gt; aft</code>之间，插入完毕后 <code>pre -&gt; vtx -&gt; aft</code>。</p><p>（7）最后返回插入的那个结点。</p><h1>六、链表结点的删除</h1><h2 id="1、含义-4">1、含义</h2><p>给定一个链表头和一个位置 <code>i (i &gt;= 1)</code>，将位置<code>i</code>的结点删除，并且返回被删除的结点。</p><p>（由于第 <code>0 </code>个结点是虚拟结点不能删除，所以<code> i</code> 从 <code>1 </code>开始）</p><h2 id="2、源码-4">2、源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">ListDeleteNode</span><span class="params">(ListNode *head, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    ListNode *pre, *del, *aft;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    pre = head;<span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">while</span>(pre &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;<span class="comment">//(2)</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!pre || !pre-&gt;next) &#123;<span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    del = pre-&gt;next;<span class="comment">//(4)</span></span><br><span class="line">    aft = del-&gt;next;</span><br><span class="line">    pre-&gt;next = aft;<span class="comment">//(5)</span></span><br><span class="line">    <span class="built_in">free</span>(del);<span class="comment">//(6)</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）第 <code>0</code> 个结点为虚拟头结点，规定不能删除，所以<code>i</code>从 <code>1</code> 开始</p><p>（2）从 <strong>链表头结点</strong> 开始遍历链表，找到将要被删除结点的 <strong>前驱结点</strong> <code>pre</code></p><p>（3）如果 <strong>前驱结点</strong> 为空，或者 <strong>需要删除的结点</strong> 为空，则直接返回当前 <strong>链表头结点</strong></p><p>（4）缓存需要删除的结点到 <code>del</code>，缓存需要删除结点的 <strong>后继结点</strong> 到<code> aft</code></p><p>（5）将需要删除的结点的 <strong>前驱结点</strong>指向它的 <strong>后继结点</strong>，实现对目标节点的删除</p><p>（6）释放需要删除结点的内存空间，返回链表头结点</p><h1>七、链表结点的查找</h1><h2 id="1、含义-5">1、含义</h2><p>即给定一个值，通过遍历链表找到链表值和给定值相等的那个结点。</p><h2 id="2、源码-5">2、源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">ListFindNodeByValue</span><span class="params">(ListNode *head, DataType v)</span> &#123;</span><br><span class="line">    ListNode *tmp = head;<span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">while</span>(tmp) &#123;<span class="comment">//(2)</span></span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;data == v) &#123;</span><br><span class="line">        <span class="keyword">return</span> tmp;<span class="comment">//(3)</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//(4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）从虚拟头结点开始遍历链表结点</p><p>（2）如果当前链表结点非空并且数据域不等于给定值，则继续访问它的后继结点，直到条件不成立</p><p>（3）返回最后访问到的那个结点</p><p>（4）未找到对应值，则返回空节点</p><h1>八、链表结点的修改</h1><h2 id="1、含义-6">1、含义</h2><p>给定一个链表头、一个位置 <code>i (i &gt;= 1)</code>和一个值<code> data</code>，将位置<code>i</code>的结点值修改为<code> data</code>，并且返回这个结点</p><h2 id="2、源码-6">2、源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LinkedListSet</span><span class="params">(head, i, data)</span> &#123;</span><br><span class="line">    ListNode *tmp = ListGetNode(head, i);</span><br><span class="line">    <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">    tmp-&gt;data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用索引获取第 i 个链表结点，如果能够找到则将它的值赋值为 data</p><h1>十、习题</h1><p><a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/description/">面试题 02.02. 返回倒数第 k 个节点 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/description/">237. 删除链表中的节点 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><p><em>题解这种东西，看力扣上的大犇就好啦~</em></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Daily Training </tag>
            
            <tag> Link List </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/2023/11/18/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2023/11/18/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1>前缀和</h1><h2 id="前言">前言</h2><blockquote><p>前缀和是应用于顺序表的算法，用来储存顺序表前n项的和。</p></blockquote><h2 id="一、朴素前缀和">一、朴素前缀和</h2><h3 id="1、部分和">1、部分和</h3><p>所谓 <strong>部分和</strong>，就是给定一个数组，求它的某一段连续子数组的和。</p><h3 id="2、朴素做法">2、朴素做法</h3><p>比较传统的做法，就是对于要求部分和的区间 <strong>[l, r]</strong>，枚举所有的数进行相加，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partialSum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时时间复杂度最坏为O(mn)。有没有办法优化呢？</p><h3 id="3、前缀和">3、前缀和</h3><p>我们可以用一个 sum[] 数组来表示数组的前缀和，即 sum[i] 表示的是前 i 项的和，数学公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></munderover><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum[i] = \sum_{k=0}^{i}a[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1138em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span></span></p><p>将 <strong>i-1</strong> 代入上述的 <strong>i</strong>，得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum[i-1] = \sum_{k=0}^{i-1}a[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1138em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span></span></p><p>于是可以得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum[i]=sum[i-1]+a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>注意由于<code>sum[-1]</code>非法，因此应当单独定义<code>sum[0] = a[0]</code>。</p><h3 id="4、再看部分和">4、再看部分和</h3><p>然后，我们继续来看部分和，有了前缀和数组 sum[] 以后，我们就可以利用差分法，在 O(1) 的时间内求得部分和，原因就是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mi>l</mi></mrow><mi>r</mi></munderover><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>r</mi></munderover><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\sum_{k=l}^{r}a[k]=\sum_{k=0}^{r}a[k]-\sum_{k=0}^{l-1}a[k]=sum[r]-sum[l-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9535em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9535em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.1382em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p><p>于是，只要预先将前缀和全部求出来，后面每次询问都可以做到 O(1) 了。</p><h2 id="二、前缀和变形">二、前缀和变形</h2><h3 id="1、前缀积">1、前缀积</h3><p>顾名思义，我们可以用一个 prod[] 数组来表示数组的前缀积，即 prod[i] 表示的是前 i 项的积，数学公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></munderover><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">prod[i]=\prod_{k=0}^{i}a[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1138em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span></span></p><p>将 i-1 代入上述的 i，得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">prod[i-1]=\prod_{k=0}^{i-1}a[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1138em;vertical-align:-1.3021em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span></span></p><p>于是可以得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">prod[i]=prod[i-1]\times a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><h3 id="2、前缀异或和">2、前缀异或和</h3><p>同样，还有前缀异或和，同样满足这个性质，如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mtext> </mtext><mi>x</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">xsum[i]=xsum[i-1] \ xor \ a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace"> </span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>其中<code>xor</code>为异或运算符<code>^</code>。（因为不知道在LaTex语法里要怎么打出这个符号所以就这样代替了……）</p><h2 id="三、练习">三、练习</h2><p><a href="https://leetcode.cn/problems/find-the-pivot-integer/description/">2485. 找出中枢整数 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/description/">1588. 所有奇数长度子数组的和 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/submissions/483105712/">930. 和相同的二元子数组 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/contiguous-array/description/">525. 连续数组 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Prefix Sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2023/11/14/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2023/11/14/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1>双指针</h1><h5 id="前言">前言</h5><blockquote><p>《算法导论》上是看不到的<code>双指针</code>的，因为无论是思考过程还是代码实现上都是非常容易理解，所以各大算法书上都不屑将它归为算法，但是它却作为职场面试，省赛水题的绝佳选择，它有一个比较优雅的名字叫 <code>尺取法</code>，英文把它叫 <code>two pointers</code>，也就是 <code>双指针</code> 的意思。需要注意的是，这个算法一般而言跟<code>指针</code>关系不大，不要被名字骗了……</p></blockquote><h2 id="一、最长不重复子串">一、最长不重复子串</h2><blockquote><p>给定一个长度为 n (1 ≤ n ≤ 10^7^) 的字符串 s，求一个最长的满足所有字符不重复的子串。</p></blockquote><h3 id="1、初步分析">1、初步分析</h3><p>首先我们分析一下这个问题的关键词，主要有以下几个：</p><p><strong>1）n ≤ 10^7^；</strong></p><p><strong>2）最长；</strong></p><p><strong>3）所有字符不重复；</strong></p><p><strong>4）子串；</strong></p><p>根据以上的几个关键词，我们可以得出一些结论。首先，根据 n 的范围已经能够大致确认这是一个需要 O(n) 或者 O(nlogn) 的算法才能解决的问题；其次，“最长” 这个词告诉我们，可能是一个动态规划问题或者贪心问题，也有可能是搜索，所以这个关键词给我们的信息用处不大；而判断字符是否重复可以用 哈希表 在 O(1) 的时间内判断；最后，枚举所有 “子串” 的时间复杂度是 O(n^2) 的。</p><h3 id="2、朴素算法">2、朴素算法</h3><p>由以上分析，我们可以发现第（1）个 和 第（4）个关键词给我们得出的结论是矛盾的，那么，我们可以先尝试减小 n 的范围，如果 n ≤ 1000 时，怎么解决这个问题呢？</p><p>因为最后求的是满足条件的最长子串，所以我们如果能够枚举所有子串，那么选择长度最长的满足条件的子串就是答案了（这里的条件是指子串中所有字符都不同）。</p><blockquote><p>用 ans 记录我们需要求的最大不重复子串的长度，用一个哈希表 h 来代表某个字符是否出现过，算法描述如下：</p><p>1）枚举子串的左端点 i = 0 -&gt; n-1；</p><p>2）清空哈希表 h；</p><p>3）枚举子串的右端点 j = i -&gt; n-1，如果当前这个字符 s[j] 出现过（即 h[ s[j] ] 为 true），则跳出 j 的循环；否则，令 h[ s[j] ] 为 true，并且用当前长度去更新 ans（即 ans= max(ans, j - i +1) ）；</p><p>4）回到 2）；</p></blockquote><p>c语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getmaxlen</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, i, j, len;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 1)</span></span><br><span class="line">        j = i;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="literal">false</span>, <span class="keyword">sizeof</span>(h)); <span class="comment">// 2)</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; !h[str[j]]) &#123;</span><br><span class="line">            h[ str[j] ] = <span class="literal">true</span>; <span class="comment">// 3)</span></span><br><span class="line">            len = j - i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; ans)</span><br><span class="line">                ans = len, l = i, r = j;</span><br><span class="line">            ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）这一步枚举对应子串的左端点 i；</p><p>2）这一步用于清空哈希表 h，其中 h[ s[j] ] 为 true 代表原字符串的第 j 个字符 s[j] 是否出现在以第 i 个字符为左端点的子串中；</p><p>3）而第三步可以这么理解：如果字符串 s[i:j] 中已经出现重复的字符，那么 s[i:j+1]，s[i:j+2], … , s[i:n-1] 必然会有重复字符，所以这里不需要继续往下枚举，直接跳出第二层循环即可。</p><p>这个算法执行完毕，ans 就是我们要求的最长不重复子串的长度，[l, r] 代表了最长不重复子串在原字符串的区间。正确性毋庸置疑，因为已经枚举了所有子串的情况，如果字符集的个数 z，算法的时间复杂度就是 O(nz)。</p><p>最后奉上一张动图，代表了上述朴素算法的求解过程，如图所示：</p><img src="../img/Fus0YmnXxIbGxqSTLKgrhI-Nb6zT.gif" alt="Fus0YmnXxIbGxqSTLKgrhI-Nb6zT" style="zoom:80%;" /><p>字符串下标从 0 开始，最长无重复子串为：s[1:5] = bcaed，长度为 5。</p><p>由于是字符串，字符集的个数 z 最多 256，所以时间复杂度基本就是 O(256n)，当 n ≤ 10^7 时，这个时间复杂度是无法接受的，需要想办法优化。</p><h3 id="3、优化算法">3、优化算法</h3><p>如果仔细思考上面朴素算法的求解过程，就会发现：枚举子串的时候有很多区间是重叠的，所以必然存在许多没有必要的重复计算。</p><p>我们考虑一个子串以 s[i] 为左端点，s[j] 为右端点，且 s[i:j-1] 中不存在重复字符，s[i:j] 中存在重复字符（换言之，s[j] 和 s[i:j-1] 中某个字符相同）。</p><p>那么我们没必要再去检测 s[i:j+1]，s[i:j+2]，s[i:n-1] 这几个字符串的合法性，因为当前情况 s[i:j] 是非法的，而这些字符串是完全包含 s[i:j] 的，所以它们必然也是不合法的。</p><p>那么我们可以把枚举的左端点自增，即： i = i +1，这时，按照朴素算法的实现，右端点需要重置，即 j = i，而实际上这里的右端点可以不动。</p><p>可以这么考虑，由于 s[j] 这个字符和 s[i:j-1] 中的字符产生了重复，假设这个重复的字符的下标为 k，那么 i 必须满足 i ≥ k，换言之， i 可以一直自增，直到 i = k+1，如图所示</p><img src="../img/Ftq7MR4620P64r4tIr6EYWwDwkGP.gif" alt="Ftq7MR4620P64r4tIr6EYWwDwkGP" style="zoom:80%;" /><p>利用上述思路，我们重新实现 最长不重复子串 的算法，C语言代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getmaxlen</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">-1</span>, len; <span class="comment">// 1)</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h)); <span class="comment">// 2)</span></span><br><span class="line">    <span class="keyword">while</span> (j++ &lt; n - <span class="number">1</span>) &#123; <span class="comment">// 3)</span></span><br><span class="line">        ++h[ str[j] ]; <span class="comment">// 4)</span></span><br><span class="line">        <span class="keyword">while</span> (h[ str[j] ] &gt; <span class="number">1</span>) &#123; <span class="comment">// 5)</span></span><br><span class="line">            --h[ str[i] ];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        len = j - i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; ans) <span class="comment">// 6)</span></span><br><span class="line">        ans = len, l = i, r = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）初始化 i = 0, j = -1，代表 s[i:j] 为一个空串，从空串开始枚举；</p><p>2）同样需要维护一个哈希表，哈希表记录的是当前枚举的区间 s[i:j] 中每个字符的个数；</p><p>3）只推进子串的右端点；</p><p>4）在哈希表中记录字符的个数；</p><p>5）当 h[ str[j] ] &gt; 1 满足时，代表出现了重复字符，这时候左端点 i 推进，直到没有重复字符为止；</p><p>6）记录当前最优解 j-i+1；</p><p>这个算法执行完毕，我们就可以得到最长不重复子串的长度为 ans，并且 i 和 j 这两个指针分别只自增 n 次，两者自增相互独立，是一个相加而非相乘的关系，所以这个算法的时间复杂度为 O(n) 。</p><p>利用该优化算法优化后的最长不重复子串的求解过程如图所示：</p><img src="../img/FjJ4MKsh0soAU40CEh5Pf5puZOqq.gif" alt="FjJ4MKsh0soAU40CEh5Pf5puZOqq" style="zoom:80%;" /><p>参考这个图，一个比较通俗易懂的解释：当区间 [i, j] 中存在重复（红色）字符时，左指针 i 自增；否则，右指针 j 自增。</p><h2 id="二、双指针">二、双指针</h2><h3 id="1、算法定义">1、算法定义</h3><p>如上文所述，这种利用问题特性，通过两个指针，不断调整区间，从而求出问题最优解的算法就叫 “尺取法”，由于利用的是两个指针，所以又叫 “双指针” 算法。</p><p>这里 “尺” 的含义，主要还是因为这类问题，最终要求解的都是连续的序列（子串），就好比一把尺子一样，故而得名。</p><h3 id="2、算法描述">2、算法描述</h3><blockquote><p>算法描述如下：</p><p>1）初始化 i=0, j=i-1，代表一开始 “尺子” 的长度为 0；</p><p>2）增加 “尺子” 的长度，即 j = j +1；</p><p>3）判断当前这把 “尺子” [i, j] 是否满足题目给出的条件：</p><p>3.a）如果不满足，则减小 “尺子” 长度，即 i = i + 1，回到 3）；</p><p>3.b）如果满足，记录最优解，回到 2）；</p></blockquote><p>上面这段文字描述的比较官方，其实这个算法的核心，只有一句话：</p><p><strong>满足条件时，j++；不满足条件时，i++；</strong></p><p>如图所示，当区间 [i, j] 满足条件时，用蓝色表示，此时 j 自增；反之闪红，此时 i 自增。</p><img src="../img/FgwnGM2aUC7Cur0Oy-uasQ84N7iW.gif" alt="FgwnGM2aUC7Cur0Oy-uasQ84N7iW" style="zoom:80%;" /><h3 id="3、条件">3、条件</h3><p>这里所说的条件比较模糊，对于【例题1】来说，条件就是 “字符不重复”，当然也可以是 “每个字符重复次数不超过 k 次”，“至少包含 k 种字符”，“求和不大于 k” 等等，因题而异。</p><p>然而，无论问题怎么变，这里的条件都需要满足以下两点：</p><h4 id="1）单调性">1）单调性</h4><p>所谓单调性，就是说：任意一个指针的增加，条件满足与否只会出现两种情况，即 ： 【满足 -&gt; 不满足】或者 【不满足 -&gt; 满足】，不会出现 【满足 -&gt; 不满足 -&gt; 满足】这样的情况。</p><h4 id="2）时效性">2）时效性</h4><p>所谓时效性，就是说：必须在 O(1) 或者 O(log_2n) 的时间内，求出当前区间 [i, j] 是否满足既定条件，否则无法用这种算法求解。</p><h2 id="三、习题">三、习题</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/is-subsequence/description/">392. 判断子序列 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心</title>
      <link href="/2023/11/12/%E8%B4%AA%E5%BF%83/"/>
      <url>/2023/11/12/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1>贪心</h1><h4 id="一、概念定义"><strong>一、概念定义</strong></h4><p>所谓贪心，总是做出在当前看来是最好的选择。也就是说，不从整体最优上进行考虑，算法得到的是在某种意义上的局部最优解。</p><p>比如，对于一个全是正整数的数组，我要找到其中两个数，使得它们的乘积最大，毫无疑问，一定是取 <strong>最大</strong> 和 <strong>次大</strong> 的两个数进行相乘，得到的结果最大。这个就是贪心思想。</p><p>贪心是一种抽象的算法，需要的不仅仅是积累，往往还有灵光一现。</p><h4 id="二、例题分析"><strong>二、例题分析</strong></h4><p><strong>1、最大乘积差</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProductDifference</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);<span class="comment">//先对数组进行排序</span></span><br><span class="line">    <span class="keyword">return</span> nums[numsSize - <span class="number">1</span>] * nums[numsSize - <span class="number">2</span>] - nums[<span class="number">0</span>] * nums[<span class="number">1</span>];<span class="comment">//利用贪心，直接取最大的两个数下标作为 w 和 x，最小的两个数下标作为 y 和 z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、三角形的最大周长</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">largestPerimeter</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = numsSize - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>] + nums[i<span class="number">-2</span>]) <span class="comment">//利用三角形两边之和大于第三边的性质，假设小的两条边为 a 和 b，大的那条为 c，那么必须满足如下等式才能满足它是一个三角形： a + b &gt; c</span></span><br><span class="line">            <span class="keyword">return</span> nums[i] + nums[i<span class="number">-1</span>] + nums[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题要求最大的三角形周长，那么势必是最大的那条边 c 越大越好，所以我们可以枚举将所有的边按照递增排序，然后逆序枚举最大的那条边 c，去剩下的边里找小的两条边，最好的情况肯定是比 c 小的最大和次大边最优，如果这两条边都不能满足上述不等式，剩下的边也就肯定也不满足了，所以只需要一个循环即可解决问题。</p><p><strong>3、分发饼干</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>* g, <span class="type">int</span> gSize, <span class="type">int</span>* s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = gSize, n = sSize;</span><br><span class="line">    qsort(g, m, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    qsort(s, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);<span class="comment">//分别对 胃口值 和 饼干 都进行递增排序</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i++, j++) &#123;<span class="comment">//然后将两个游标都指向 胃口值 和 饼干 的开头</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; g[i] &gt; s[j]) &#123;  <span class="comment">//不满足，饼干 的游标往后移动一格，寻找更加容易满足条件的解，直到 饼干 或者 胃口值 枚举完毕</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n) &#123;<span class="comment">//如果某一个 饼干 和 胃口值 满足条件，则答案加一</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、练习"><strong>三、练习</strong></h4><p><a href="https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs/">两个数对之间的最大乘积差</a></p><p><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">三角形的最大周长</a></p><p><a href="https://leetcode.cn/problems/array-partition/">数组拆分</a></p><p><a href="https://leetcode-cn.com/problems/boats-to-save-people/">救生艇</a></p><p><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/">摆动排序 II</a></p><p><a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></p><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-increasing/">最少操作使数组递增</a></p><p><a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/">使数组唯一的最小增量</a></p><p><a href="https://leetcode-cn.com/problems/valid-triangle-number/">有效三角形的个数</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Greedy Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递推</title>
      <link href="/2023/11/09/%E9%80%92%E6%8E%A8/"/>
      <url>/2023/11/09/%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<h1>递推</h1><h2 id="前言">前言</h2><blockquote><p>递推最通俗的理解就是数列，递推和数列的关系就好比 算法 和 数据结构 的关系，数列有点像数据结构中的顺序表，而递推就是一个循环或者迭代的枚举过程。</p><p>递推本质上是数学问题，所以有同学问算法是不是需要数学非常好，也并不是，你会发现，这些数学只不过是初中高中我们学烂的东西，高考都经历了，这些东西又何足为惧！?</p></blockquote><h2 id="一、斐波那契数列">一、斐波那契数列</h2><blockquote><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1</p><p>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1，给定 n(0 ≤ n ≤ 30) ，请计算 F(n) 。</p></blockquote><p>拿到这个题目，我们首先来看题目范围， 最多不超过 30，那是因为斐波那契数的增长速度很快，是指数级别的。所以如果  n 很大，就会超过 c语言 中32位整型的范围。这是一个最基础的递推题，递推公式都已经告诉你了，我们要做的就是利用一个循环来实现这个递推。</p><p>我们只需要用一个 F[31] 数组，初始化好 F[0] 和 F[1]，然后按照给定的公式循环计算就可以了。像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// (1)</span></span><br><span class="line">    <span class="type">int</span> F[<span class="number">31</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; ++i) &#123; <span class="comment">// (3)</span></span><br><span class="line">        F[i] = F[i<span class="number">-1</span>] + F[i<span class="number">-2</span>]; <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F[n]; <span class="comment">// (5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>(1) 首先定义一个循环变量；</li><li>(2) 再定义一个数组记录斐波那契数列的第 n 项，并且初始化第 0 项 和 第 1 项。</li><li>(3) 然后一个 for 循环，从第 2 项开始；</li><li>(4) 利用递推公式逐步计算每一项的值；</li><li>(5) 最后返回第 n 项即可。</li></ol><h2 id="二、泰波那契数列">二、泰波那契数列</h2><blockquote><p>泰波那契序列 Tn 定义如下：</p><p>T(0) = 0, T(1) = 1, T(2) = 1</p><p>且在 n &gt; 2 的条件下 T(n) = T(n-1) + T(n-2) + T(n-3)，给你整数 n，请返回第 n 个泰波那契数 T(n) 的值。</p></blockquote><p>如果已经理解斐波那契数列，那么这个问题也不难，只不过初始化的时候，需要初始化前三个数，并且在循环迭代计算的时候，当前数的值需要前三个数的值累加和。像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> T[<span class="number">100</span>];</span><br><span class="line">    T[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    T[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    T[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    T[i] = T[i<span class="number">-1</span>] + T[i<span class="number">-2</span>] + T[i<span class="number">-3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、斐波那契数列变形">三、斐波那契数列变形</h2><blockquote><p>给定一个 n(1 ≤ n ≤ 45) 代表总共有 n 阶楼梯，一开始在第 n 阶，每次可以爬 1 或者 2 个台阶，问总共有多少种不同的方法可以爬到楼顶。</p></blockquote><p>我们定义一个数组 f[46]，其中 f[i] 表示从第  0 阶爬到第 i  阶的方案数。由于每次可以爬 1 或者 2 个台阶，所以对于第 i 阶楼梯来说，所以要么是从第 i-1 阶爬过来的，要么是从 i-2  阶爬过来的。</p><p>于是得出一个递推公式：f[i] = f[i-1] + f[i-2]。</p><p>我们发现这个就是斐波那契数列，你可以叫它递推公式，也可以叫它状态转移方程。这里的 f[i]  就是状态的概念，从一个状态到另一个状态就叫状态转移。</p><p>当然我们还要考虑初始状态，f[0] 代表从第 0 阶到第 0 阶的方案数，当然就是 1 啦，f[1] 代表从第 0 阶到第 1 阶的方案数，由于只能走 1 阶，所以方案数也是 1。</p><p>代码就不再累述了。</p><h3 id="四、二维递推问题">四、二维递推问题</h3><p>像斐波那契数列这种问题，是一个一维的数组来解决的，有些时候，一维解决不了的时候，我们就需要升高一个维度来看问题了。</p><blockquote><p>长度为 n(1≤n&lt;40) 的只由 ‘A’、‘C’、'M’三种字符组成的字符串（可以只有其中一种或两种字符，但绝对不能有其他字符）且禁止出现 M 相邻的情况，问这样的串有多少种？</p></blockquote><p>考虑长度为 n，且以 ‘A’ 结尾的串有 f[n][0] 种、以 ‘C’ 结尾的串有 f[n][1] 种、以 ‘M’ 结尾的串有 f[n][2] 种，那么我们要求的答案就是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{2} f[n][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>如果第 n 个结尾的字符是 ‘A’ 或者 ‘C’，那么显然， 第 n−1 个字符可以是任意字符；而如果第 n 个结尾的字符是 ‘M’，那么第 n−1 个字符只能是是 ‘A’ 或者 ‘C’。所以可以得到递推公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][0] = f[n-1][0]+f[n-1][1]+f[n-1][2] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][1]=f[n-1][0]+f[n-1][1]+f[n-1][2] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][2]=f[n-1][0]+f[n-1][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p><p>到这一步，我们就可以利用程序求解了，但是，还可以化解，由于</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{2} f[n][i]=f[n][0]+f[n][1]+f[n][2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p><p>于是，可以得出：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][0]=\sum_{i=0}^{2} f[n-1][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][1]=\sum_{i=0}^{2} f[n-1][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[n][2]=\sum_{i=0}^{2} f[n-2][i]+\sum_{i=0}^{2} f[n-2][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>从而得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{2}f[n][i]= 2 \times (\sum_{i=0}^{2}f[n-1][i]+\sum_{i=0}^{2}f[n-2][i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p><p>令</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>2</mn></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g[n]=\sum_{i=0}^{2}f[n][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>原式可以化解为如下递推式（升维再降维）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>g</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g[n]=2\times(g[n-1]+g[n-2])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">])</span></span></span></span></span></p><p>然后我们手动算出长度为 1 和 长度为 2 的串的方案数，递推代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">getACM</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> g[<span class="number">40</span>];</span><br><span class="line">    g[<span class="number">1</span>] = <span class="number">3</span>, g[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    g[i] = <span class="number">2</span> * (g[i<span class="number">-1</span>] + g[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="习题">习题</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/submissions/481025216/">70. 爬楼梯 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/three-steps-problem-lcci/submissions/481023120/">面试题 08.01. 三步问题 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/submissions/481035103/">1997. 访问完所有房间的第一天 - 力扣（LeetCode）</a></p><h4 id="访问完所有房间的第一天">访问完所有房间的第一天</h4><h5 id="思路分析">思路分析</h5><p>动态规划，dp[i]表示从0房间到第i个房间所需要的时间。</p><p>根据0&lt;=nextVisit[i]&lt;=i可以判定访问次数为基数时必回退到小于等于i的某个点，为偶数时才会 +1，故从dp[i+1]=dp[i]+(dp[i]-dp[nextVisit[i]])+2</p><p>公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>V</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[i]=2∗dp[i−1]−dp[nextVisit[i−1]]+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mord mathnormal">Vi</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></span></p><h5 id="代码">代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">firstDayBeenInAllRooms</span><span class="params">(<span class="type">int</span>* nextVisit, <span class="type">int</span> nextVisitSize)</span>&#123;</span><br><span class="line">    <span class="type">long</span>* dp = <span class="built_in">malloc</span>(nextVisitSize*<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mod = (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nextVisitSize;i++)&#123;</span><br><span class="line">        dp[i] = (<span class="number">2</span>*dp[i<span class="number">-1</span>]-dp[nextVisit[i<span class="number">-1</span>]]+<span class="number">2</span>+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)dp[nextVisitSize<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Extrapolation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟</title>
      <link href="/2023/11/06/%E6%A8%A1%E6%8B%9F/"/>
      <url>/2023/11/06/%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1>模拟</h1><h2 id="前言">前言</h2><blockquote><p>模拟算法其实就是根据题目做，题目要求什么，就做什么。</p></blockquote><h2 id="一、数据结构">一、数据结构</h2><p>对于模拟题而言，最关键的其实是数据结构，看到一个问题，选择合适的数据结构，然后根据问题来实现对应的功能。模拟题的常见数据结构主要就是：数组、字符串、矩阵、链表 等等。</p><h3 id="1、基于数组">1、基于数组</h3><p>利用数组的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/build-array-from-permutation/">1920. 基于排列构建数组</a>、<a href="https://leetcode.cn/problems/create-target-array-in-the-given-order/">1389. 按既定顺序创建目标数组</a>、<a href="https://leetcode.cn/problems/design-parking-system/">1603. 设计停车系统</a>、<a href="https://leetcode.cn/problems/rearrange-array-elements-by-sign/">2149. 按符号重排数组</a>、<a href="https://leetcode.cn/problems/find-triangular-sum-of-an-array/">2221. 数组的三角和</a></p><h3 id="2、基于字符串">2、基于字符串</h3><p>利用字符串的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/">2011. 执行操作后的变量值</a>、<a href="https://leetcode.cn/problems/find-maximum-number-of-string-pairs/">2744. 最大字符串配对数目</a>、<a href="https://leetcode.cn/problems/nGK0Fy/">LCP 17. 速算机器人</a>、<a href="https://leetcode.cn/problems/complex-number-multiplication/">537. 复数乘法</a></p><h3 id="3、基于链表">3、基于链表</h3><p>利用链表的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/merge-nodes-in-between-zeros/">2181. 合并零之间的节点</a>、<a href="https://leetcode.cn/problems/find-the-winner-of-the-circular-game/">1823. 找出游戏的获胜者</a></p><h3 id="4、基于矩阵">4、基于矩阵</h3><p>利用矩阵的数据结构，根据题目要求，去实现算法，如：<a href="https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/">2120. 执行所有后缀指令</a>、<a href="https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/">1252. 奇数值单元格的数目</a>、<a href="https://leetcode.cn/problems/flipping-an-image/">832. 翻转图像</a>、<a href="https://leetcode.cn/problems/robot-return-to-origin/">657. 机器人能否返回原点</a>、<a href="https://leetcode.cn/problems/game-of-life/">289. 生命游戏</a>、<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a>、<a href="https://leetcode.cn/problems/spiral-matrix-iii/">885. 螺旋矩阵 III</a></p><h3 id="5、基于栈">5、基于栈</h3><p>利用栈的数据结构，如：<a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/">1441. 用栈操作构建数组</a></p><h3 id="6、基于队列">6、基于队列</h3><p>利用队列的数据结构，如：<a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></p><h2 id="二、算法技巧">二、算法技巧</h2><p>模拟时一般会用到一些算法技巧，或者说混合算法，比如 排序、递归、迭代 等等。</p><h3 id="1、排序">1、排序</h3><p>排序后，干一件事情，如：<a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/">950. 按递增顺序显示卡牌</a></p><h3 id="2、递归">2、递归</h3><p>需要借助递归来实现，如：<a href="https://leetcode.cn/problems/count-of-matches-in-tournament/">1688. 比赛中的配对次数</a> 、<a href="https://leetcode.cn/problems/count-operations-to-obtain-zero/">2169. 得到 0 的操作数</a>、<a href="https://leetcode.cn/problems/add-digits/">258. 各位相加</a></p><h3 id="3、迭代">3、迭代</h3><p>不断迭代求解，其实就是利用 while 循环来实现功能，如：<a href="https://leetcode.cn/problems/incremental-memory-leak/">1860. 增长的内存泄露</a>、<a href="https://leetcode.cn/problems/add-digits/">258. 各位相加</a></p><h2 id="三、实例">三、实例</h2><ol><li><a href="https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/submissions/480232981/">1252. 奇数值单元格的数目 - 力扣（LeetCode）</a></li></ol><h4 id="题目">题目</h4><blockquote><p>给你一个 <code>m x n</code> 的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p><p>另有一个二维索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 指向矩阵中的某个位置，其中 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（<strong>从 <code>0</code> 开始编号</strong>）。</p><p>对 <code>indices[i]</code> 所指向的每个位置，应同时执行下述增量操作：</p><ol><li><code>ri</code> 行上的所有单元格，加 <code>1</code> 。</li><li><code>ci</code> 列上的所有单元格，加 <code>1</code> 。</li></ol><p>给你 <code>m</code>、<code>n</code> 和 <code>indices</code> 。请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 <strong>奇数值单元格</strong> 的数目。</p></blockquote><h4 id="思路">思路</h4><p>按要求进行操作即可。</p><h4 id="代码">代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">oddCells</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span>** indices, <span class="type">int</span> indicesSize, <span class="type">int</span>* indicesColSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, r, c;</span><br><span class="line">    <span class="type">int</span> mat[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(mat));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; indicesSize; ++i) &#123;</span><br><span class="line">        r = indices[i][<span class="number">0</span>];</span><br><span class="line">        c = indices[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; m; ++j) &#123;</span><br><span class="line">            mat[j][c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            mat[r][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mat[i][j] &amp; <span class="number">1</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/complex-number-multiplication/solutions/1283204/fu-shu-cheng-fa-by-leetcode-solution-163i/">537. 复数乘法 - 力扣（LeetCode）</a></li></ol><h4 id="题目-2">题目</h4><blockquote><p><a href="https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0/254365?fr=aladdin">复数</a> 可以用字符串表示，遵循 <strong><code>&quot;实部+虚部i&quot;</code></strong> 的形式，并满足下述条件：</p><ul><li><code>实部</code> 是一个整数，取值范围是 <code>[-100, 100]</code></li><li><code>虚部</code> 也是一个整数，取值范围是 <code>[-100, 100]</code></li><li><code>i2 == -1</code></li></ul><p>给你两个字符串表示的复数 <code>num1</code> 和 <code>num2</code> ，请你遵循复数表示形式，返回表示它们乘积的字符串。</p></blockquote><h4 id="思路-2">思路</h4><p>由于直接从头到尾模拟将会耗费大量时间且毫无意义（实现读取实部和虚部的函数，实现字符串转数字的函数，还有他们的反函数等等），因此在这里采取格式化的措施。优点是简洁易读，缺点是效率不咋地。</p><h4 id="代码-2">代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">complexNumberMultiply</span><span class="params">(<span class="type">char</span>* num1, <span class="type">char</span>* num2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> real1, imag1, real2, imag2;</span><br><span class="line">    <span class="built_in">sscanf</span>(num1, <span class="string">&quot;%d+%di&quot;</span>, &amp;real1, &amp;imag1);</span><br><span class="line">    <span class="built_in">sscanf</span>(num2, <span class="string">&quot;%d+%di&quot;</span>, &amp;real2, &amp;imag2);</span><br><span class="line">    <span class="type">char</span> *ans = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(ans, <span class="string">&quot;%d+%di&quot;</span>, real1 * real2 - imag1 * imag2, real1 * imag2 + real2 * imag1);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2023/11/06/%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/11/06/%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1>枚举</h1><h2 id="定义">定义</h2><blockquote><p>枚举的概念就是把满足题目条件的所有情况都列举出来，然后一一判定，找到最优解的过程。</p></blockquote><h2 id="一、最值问题">一、最值问题</h2><p>比较经典的枚举问题莫过于最值问题了，也就是求一堆数中的最大值或者最小值。</p><h3 id="1、两个数的最值问题">1、两个数的最值问题</h3><p>两个数的最小值，利用C语言中的三元运算符就可以实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、n-个数的最值问题">2、n 个数的最值问题</h3><p>当有 n 个数时 ai 时，我们可以首先取前两个数，计算最小值；然后再拿这个最小值和第三个数去比较，得到的最小值再去和第四个数比较，以此类推，就可以计算出 n 个数中的最小值。</p><p>假设前 i 个数的最小值为 mi，则有递推公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>a</mi><mi>i</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}m_{i}=\left\{\begin{aligned}a_{i} &amp;&amp; i=0 \\min(m_{i-1}, a_{i}) &amp;&amp; i&gt;0 \\\end{aligned}\right.\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:3.75em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></p><p>所以，把这个递推公式翻译成C语言，代码是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NMin</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *m = (<span class="type">int</span> *) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize );</span><br><span class="line">    <span class="type">int</span> m[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    m[i] = Min(m[i<span class="number">-1</span>], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = m[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的 m[i] 和 m[i-1] 可以利用迭代，存储在一个变量中，用 C语言实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NMin</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    m = Min(m, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、最值问题的下标">3、最值问题的下标</h3><p>当然，有些时候，我们求的并不是一个最小的数，要是要求出这个数组中，最小的数的下标，那么可以直接记录下标，并且比较的时候直接通过下标去索引到值，然后进行比较，像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NMin</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> mIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( a[i] &lt; a[mIdx] ) &#123;</span><br><span class="line">        mIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以尝试做一下这道题，巩固一下概念：<a href="https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/description/">2656. K 个元素的最大和 - 力扣（LeetCode）</a></p><h2 id="二、最值问题的进阶">二、最值问题的进阶</h2><h3 id="1、第三大的数">1、第三大的数</h3><p>有时候，我们求最大的数不够，想要求次大的，甚至第三大的，比如 1 2 2 3 中第三大的是 1 （相同的数只计算一次）。</p><p>这样的问题，核心思路就是先把最大的求出来；然后忽略最大的数的情况下，再去求最大的；这时候就得到了次大的，再把次大的也忽略以后，再求最大的，自然就是第三大的了。</p><p>当然你也可以将数组排序过后选取第三大的数。那为什么要使用枚举呢？思考一下二者的时间复杂度的区别。</p><p><a href="https://leetcode.cn/problems/third-maximum-number/submissions/479969011/">414. 第三大的数 - 力扣（LeetCode）</a></p><h3 id="2、数组中两元素的最大乘积">2、数组中两元素的最大乘积</h3><p>要求找到数组中两个元素的最大乘积，数组元素一定是正数。那么我们知道最大的两个元素相乘一定是最大的，所以就是找最大的元素 和 次大的元素，但是这个问题和 第三大的数 略微有些不同，相同的数会被计算进去。</p><p>所以，我们找到最大的数以后，可以把它的下标忽略掉；然后再去找最大的数，这样找到的一定是两个可重复的最大元素和次大元素，将两者相乘即可。</p><p>当然也可以直接把数组按照递增排序，然后取最后两个元素相乘。但是与上面一样，比较排序的最优时间复杂度为 O(nlogn)，而找两次最大值的时间复杂度为 O(n)。</p><h2 id="三、降维思想">三、降维思想</h2><p><strong>慎入！因为我自己也没彻底搞明白……至少目前是这样</strong></p><p>一些统计类问题，第一个思路就是枚举所有情况（也就是多个 for 循环），然后再去考虑是不是能够把某些 for 循环的 O(n) 的时间复杂度降为 O(1)，这个就是降维的思想。来看这个经典问题：</p><p>这个问题能自己想出来，听说就达到了 ACM 区域赛铜牌的水平。</p><blockquote><p>给你一个长度为 n (n ≤ 4000) 下标从 0 开始的整数数组 nums ，它包含 1 到 n 的所有数字，请你返回上升四元组的数目。如果一个四元组 (i, j, k, l) 满足以下条件，我们称它是上升的：</p><p>1）0 &lt;= i &lt; j &lt; k &lt; l &lt; n 且</p><p>2）nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。</p></blockquote><h3 id="1、O-n-4">1、O(n^4)</h3><p>首先，最坏时间复杂度的算法，相信大家都能想出来，就是枚举 i、j、k、l 四个变量，然后判断 nums 四个数的关系，进行统计累加，这种情况下，最坏的时间复杂度为 O(n^4)，由于 n 为 4000。</p><p>也就是相当于 n = 16000000 的数据量下，用 O(n^2) 的算法去求解问题，所以必然超时。</p><h3 id="2、O-n-3">2、O(n^3)</h3><p>如果要用 O(n^3) 的算法求解，你会怎么去思考呢？如果有想法，可以写好以后附在评论区。</p><h3 id="3、O-n-2">3、O(n^2)</h3><p>是的，由于 n 的范围限制， 就算你想出了 O(n^3) 的算法，还是过不了这个问题，我们需要继续想 O(n^2) 的算法。</p><p>算法思路如下：</p><p>1、首先，我们枚举 j 和 k，然后对所有满足 nums[j] &gt; nums[k] 的下标对，执行下一步。</p><p>2、那么只要我们找到数组下标为 0 到 j-1 的数中，小于 nums[k] 的个数，记为 a（也就是所有满足条件的 i）； 找到数组下标为 k+1 到 n-1 的数中，大于 nums[j] 的个数，记为 b（也就是所有满足条件的）； 将 a * b 就是所有满足条件的 (i, l) 对，把所有的 （i, l） 数对累加，就是我们最后要求的答案了。</p><p>3、于是问题转变成了求 <strong>找到数组下标为 0 到 j-1 的数中，小于 nums[k] 的个数</strong> 和 <strong>找到数组下标为 k+1 到 n-1 的数中，大于 nums[j] 的个数；</strong></p><p>4、定义两个辅助数组 less[4001][4001] 和 bigger[4001][4001]，令 less[i][j] 表示前 i-1 个数中，小于 j 的数的个数；令 bigger[i][j] 表示 i 以后（不包括 i）的数中，大于 j 的数的个数。less 和 bigger 的含义类似，通过两个 for 循环 枚举求出 less 和 bigger。</p><p>5、最后，只要枚举 j 和 k，在满足 nums[j] &gt; nums[k] 的条件下，累加 less[j][ nums[k] * bigger[k][nums[j]] 的和，就是我们要求的解了。</p><p>看懂了吗？看懂了。那就把代码发在评论区吧~</p><p>（P.S. 哪天我搞明白了就发上去……）</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Enumeration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="/2023/11/06/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/06/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>计数排序</h1><p><strong>1. 概念定义</strong></p><p><strong>计数排序</strong>（Counting sort）是一个非基于比较的稳定的线性时间的排序算法，</p><ol><li>非基于比较：之前学的排序都是通过比较数据的大小来实现有序的，比如希尔排序等，而计数排序不用比较数据的大小。</li></ol><p>计数排序的名字会让我们想到“计数法”，实际上计数排序的实现就是使用的计数法。（类似哈希表的思想）</p><p><strong>工作原理</strong>：使用一个额外的数组 cnt，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数，然后根据数组 cnt 来将 A 中的元素排到正确的位置。</p><p><strong>具体实现</strong>：创建一个足够大的数组 cnt，足够大的意思是 cnt 的下标范围可以包括所有的待排序数据值。然后遍历待排序数据，使用计数法统计每个数据的出现次数。最后遍历 cnt 数组，将每一个值（cnt[i]）不为 0 的下标（i）放入原数组 cnt[i] 次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">101</span>];  <span class="comment">//因为最大的数据是100，所以数组下标要开到 101，否则会出现数组越界问题</span></span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));  <span class="comment">//初始化哈希表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        cnt[ s[i] ]++;  <span class="comment">//将计数的表中对应值所在位置加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; ++i) &#123;  <span class="comment">//按顺序取出哈希表中的值</span></span><br><span class="line">        <span class="keyword">while</span>(cnt[i]) &#123;</span><br><span class="line">            s[sSize++] = i;  <span class="comment">//请自行复习++i和i++的区别</span></span><br><span class="line">            cnt[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-题目练习"><strong>2. 题目练习</strong></h2><ol><li><a href="https://leetcode.cn/problems/neither-minimum-nor-maximum/description/">2733. 既不是最小值也不是最大值 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/find-the-difference/description/">389. 找不同 - 力扣（LeetCode）</a></li></ol><h2 id="3-解题报告"><strong>3. 解题报告</strong></h2><p><a href="https://leetcode.cn/problems/neither-minimum-nor-maximum/description/">2733. 既不是最小值也不是最大值 - 力扣（LeetCode）</a></p><p><strong>题目描述</strong></p><blockquote><p>给你一个整数数组 <code>nums</code> ，数组由 <strong>不同正整数</strong> 组成，请你找出并返回数组中 <strong>任一</strong> 既不是 <strong>最小值</strong> 也不是 <strong>最大值</strong> 的数字，如果不存在这样的数字，返回 <strong><code>-1</code></strong> 。</p><p>返回所选整数。</p></blockquote><ol><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>nums</code> 中的所有数字互不相同</li></ol><p><strong>解题思路</strong></p><p>将原数组排序，判断数组中的数是否与头尾元素相同，否则输出。</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        cnt[ s[i] ]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt[i]) &#123;</span><br><span class="line">            s[sSize++] = i;</span><br><span class="line">            cnt[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findNonMinOrMax</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    countingSort(nums, numsSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[numsSize<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="keyword">return</span> nums[i]; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-difference/description/">389. 找不同 - 力扣（LeetCode）</a></p><p><strong>题目描述</strong></p><blockquote><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，它们只包含小写字母。</p><p>字符串 <code>t</code> 由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <code>t</code> 中被添加的字母。</p></blockquote><ol><li><code>0 &lt;= s.length &lt;= 1000</code></li><li><code>t.length == s.length + 1</code></li><li><code>s</code> 和 <code>t</code> 只包含小写字母</li></ol><p><strong>解题思路</strong></p><p>将字符串排序，逐个比较至两者相同位置的元素不相同，输出t中该元素。</p><p>因为是字符串，排序函数需要做一些改动，按字符编码排序，并且别忘了在末尾加上终止符。</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; s[i]; ++i) &#123;</span><br><span class="line">        cnt[ s[i] ]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt[i]) &#123;</span><br><span class="line">            s[sSize++] = i;</span><br><span class="line">            cnt[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[sSize] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* t)</span> &#123;</span><br><span class="line">    countingSort(s);</span><br><span class="line">    countingSort(t);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; s[i]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != t[i]) <span class="keyword">return</span> t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目拓展</strong></p><ol><li>既然能使用计数排序，为什么不直接比较计数情况（通过哈希表）？如何实现？</li><li>既然是增加一个字符，那合并两个字符串后应该会出现有一个字母的数量是奇数。如何利用这一点改进程序？或者是采取一种新方法？（提示：位运算）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Counting Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建教程</title>
      <link href="/2023/11/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2023/11/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>博客搭建教程</h1><blockquote><p>本篇文章缝合了源自网络的多篇教程，主要目的是用来帮自己记住相关操作方法，类似备忘录。</p><p>（还有就是水文章，毕竟在博客里发布搭建博客的教程也是一种传统？）</p></blockquote><h2 id="前言">前言</h2><p>近些年来很多用户都喜欢使用 GitHub Pages 来搭建 Hexo 静态博客网站，其最吸引人的莫过于完全免费使用，并且非常稳定。</p><p>虽然搭建时比较麻烦，有点折腾，但是配置完成后，基本不需要操心维护的事，甚至放了几年都忘记了，打开来看文章依然还在。</p><p>本文就详细介绍下如何使用 Hexo + GitHub 搭建免费个人博客网站的教程。</p><h2 id="简介">简介</h2><h3 id="GitHub-Pages-是什么？">GitHub Pages 是什么？</h3><ul><li><a href="https://help.github.com/en/articles/what-is-github-pages">What is GitHub Pages? - GitHub Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h3 id="Hexo-是什么">Hexo 是什么?</h3><ul><li>官网：<a href="https://hexo.io/zh-cn/">hexo.io</a></li></ul><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p><h3 id="Hexo-GitHub-文章发布原理">Hexo + GitHub 文章发布原理</h3><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><img src="../img/Hexo + GitHub 文章发布原理.png" alt="picture" style="zoom: 33%;" /><h3 id="优点和不足">优点和不足</h3><p>**优点：**完全免费；静态站点，轻量快速；可按需求自由定制改造；托管在 GitHub，安全省心；迁移方便……</p><p>**不足：**发文不便，依赖于本地环境；更适合个人博客使用；GitHub 在国内访问速度有点不快。</p><h2 id="1-准备">1. 准备</h2><h3 id="注意事项">注意事项</h3><ul><li>输入代码时，核对准确，最好切换成英文输入法；</li><li>将文中的 “用户名” 和 “邮箱” 替换为自己的 GitHub 账户名和绑定的邮箱；</li><li>统一使用 Git Bash 进行操作；</li></ul><h3 id="环境搭建">环境搭建</h3><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。</p><ul><li>Node.js：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li><li>Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li></ul><p>下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。</p><p>安装完成后，Win+R 输入 cmd 并打开，依次输入 <code>node -v</code>、<code>npm -v</code> 和 <code>git --version</code> 并回车，如下图出现程序版本号即可。</p><img src="../img/屏幕截图1png.png" alt="picture" style="zoom:50%;" /><h2 id="2-连接-Github">2. 连接 Github</h2><p>使用邮箱注册 <a href="https://github.com/">GitHub</a> 账户，选择免费账户（Free），并完成邮件验证。</p><p>桌面按住shift右键 -&gt; Git Bash Here，<strong>设置用户名和邮箱</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>创建 SSH 密匙</strong>：</p><p>输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p><p><strong>添加密匙：</strong></p><p>进入 [C:\Users\用户名\.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p><p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p><p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p><img src="../img/屏幕截图 2023-11-04 220045.png" alt="picture" style="zoom:67%;" /><p><strong>验证连接：</strong></p><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。</p><img src="../img/屏幕截图 2023-11-04 212102.png" alt="picture" style="zoom: 67%;" /><p>显示 “Hi xxx! You’ve successfully……” 即连接成功。</p><h2 id="3-创建-Github-Pages-仓库">3. 创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>填好后点击 Create repository 创建。</p><img src="../img/屏幕截图 2023-11-04 212129.png" alt="picture" style="zoom:50%;" /><p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><h2 id="4-本地安装-Hexo-博客程序">4. 本地安装 Hexo 博客程序</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。</p><h3 id="安装-Hexo">安装 Hexo</h3><p>使用 npm 一键安装 Hexo 博客程序：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装时间有点久（想要加快可以试试魔法），界面也没任何反应，<strong>耐心等待</strong>，安装完成后如下图。</p><img src="../img/屏幕截图 2023-11-04 212141.png" alt="picture" style="zoom:67%;" /><h3 id="4-2-Hexo-初始化和本地预览">4.2 Hexo 初始化和本地预览</h3><p>新建一个文件夹作为你博客的仓库。你后面的工作将大部分在这个文件夹中完成。</p><p><strong>初始化并安装所需组件：</strong></p><p>在文件夹中按住shift右键，选择Git Bash Here（注意，以后的Git Bash最好也都这么启动）。输入下面的指令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init      # 初始化</span><br><span class="line">npm install    # 安装组件</span><br></pre></td></tr></table></figure><p>完成后依次输入下面命令，<strong>启动本地服务器进行预览</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo s   # 启动预览</span><br></pre></td></tr></table></figure><p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p><img src="../img/屏幕截图 2023-11-04 212154.png" alt="picture" style="zoom:67%;" /><p>**Tips：**如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo server -p 5000</code> 更改端口号后重试。</p><p>Hexo 博客文件夹目录结构如下：</p><img src="../img/屏幕截图 2023-11-04 212225.png" alt="picture" style="zoom: 67%;" /><h2 id="5-部署-Hexo-到-GitHub-Pages">5. 部署 Hexo 到 GitHub Pages</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先<strong>安装 hexo-deployer-git</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后<strong>修改 _config.yml</strong> 文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h2 id="6-开始使用">6. 开始使用</h2><h3 id="7-1-发布文章">7.1 发布文章</h3><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>然后 source 文件夹中会出现一个 <a href="http://My-New-Post.md">My-New-Post.md</a> 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p><p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这两条命令。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo d   # 部署发布</span><br></pre></td></tr></table></figure><hr><p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo g</code> 和 <code>hexo d</code> 发布。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">  - Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">  - PS3</span><br><span class="line">  - Games</span><br><span class="line">---</span><br><span class="line">&quot;Your article here&quot;</span><br></pre></td></tr></table></figure><h3 id="7-2-网站设置">7.2 网站设置</h3><p>包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a>按需要编辑。</p><p>注意：冒号后要加一个空格！</p><h3 id="7-3-更换主题">7.3 更换主题</h3><p>Hexo提供了非常多好看的主题（是的，经过美化后能够达各种效果），其中应用较为广泛的是Butterfly。关于更换主题和美化页面的教程，后面可能会单独写一篇文章。要是太着急的话，可以访问Hexo的官网寻找（他甚至还有简中，他真的，我哭死）。记住，最靠谱的永远是官方的手册！（RTFM, bro!）</p><h3 id="7-4-常用命令">7.4 常用命令</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure><h2 id="8-常见问题">8 常见问题</h2><p><strong>1、修改并部署后没有效果</strong></p><p>使用 <code>hexo clean</code> 清理后重新部署。</p><p><strong>2、开启 HTTPS 后访问网站显示连接不安全？</strong></p><p>证书还未部署生效，等待一会儿，清除浏览器缓存再试。</p><p><strong>3、npm 下载速度慢，甚至完全没反应</strong></p><p>使用 npm 安装程序等待很久也没反应，或者下载速度很慢，可以更换 npm 源为国内 npm 镜像。</p><p>临时更换方法：在 npm 安装命令后面加上：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--registry https://registry.npm.taobao.org </span><br></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>Hexo 是一种纯静态的博客，我们必须要在本地完成文章的编辑再部署到 GitHub 上，依赖于本地环境。不能像 WordPress 或 Typecho 那样的动态博客一样能直接在浏览器中完成撰文和发布。</p><p>可以说是一种比较极客的写博客方式，但是优势也是明显的——免费稳定省心，比较适合爱折腾研究的用户，或者没有在线发文需求的朋友。</p><p>如果在自己部署的过程中出现了问题，可以阅读官方的手册。心动不如行动，赶快行动起来吧！</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Course </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2023/11/04/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/04/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>冒泡排序</h1><p><strong>1. 概念定义</strong></p><p><strong>冒泡排序</strong>（<strong>Bubble Sort</strong>）又称为<strong>泡式排序</strong>，是一种简单的排序算法。</p><p><strong>核心思想</strong>：它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就像水中的气泡会冒起来一样。</p><p><strong>运作步骤</strong>（升序排列）：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>比如：</p><p>原始数据：3 2 7 8 6，将其按升序排列。</p><p>第一次循环：（最大的跑到最右边）</p><p>3 2 7 8 6 --&gt; 2 3 7 8 6 （3和2比较，3 &lt; 2，所以3和2交换位置）</p><p>2 3 7 8 6 --&gt; 2 3 7 8 6 （3和7比较。3 &lt; 7，所以3和7不用交换位置）</p><p>2 3 7 8 6 --&gt; 2 3 7 8 6 （7和8比较，7 &lt; 8，所以7和8不用交换位置）</p><p>2 3 7 8 6 --&gt; 2 3 7 6 8 （8和6比较，8 &gt; 6，所以8和6交换位置）</p><p>经过第1次循环，此时剩下参与比较的数据：2 3 7 6</p><p>第二次循环：</p><p>2 3 7 6 --&gt; 2 3 7 6 （2和3比较，不需要交换位置）</p><p>2 3 7 6 --&gt; 2 3 7 6 （3和7比较，不需要交换位置）</p><p>2 3 7 6 --&gt; 2 3 6 7 （7和6比较，7 &gt; 6，所以7和6交换位置）</p><p>经过第2次循环，此时剩下参与比较的数据：2 3 6</p><p>第三次循环：</p><p>2 3 6 （2和3比较，不需要交换位置）</p><p>2 3 6 （3和6比较，不需要交换位置）</p><p>经过第3次循环，此时剩下参与比较的数据：2 3</p><p>第四次循环：</p><p>2 3 （2和3比较，不需要交换位置）</p><p>至此，5个数经历了4次循环，每次循环都将当前最大的书交换的最右的位置，然后下次循环就不再考虑该数。</p><p><strong>具体实现</strong>：使用双重循环，外层循环控制循环的次数，内层循环进行数字的比较。内层每一次循环结束之后，都要找出最大的数据，放到参与比较的这堆数据的最右边，下次循环不再比较该数。</p><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i) &#123;  <span class="comment">//因为每次比较两个数，所以总共n个数，只需要比较n-1次（外循环n-1次）</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; ++j) &#123;  <span class="comment">//每次比较完后，最大的值在下一次比较中不用比较，所以每次比较只需要循环n-1-i 次（内循环n-1-i次）</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-题目练习"><strong>2. 题目练习</strong></h2><ol><li><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></li><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></li><li><a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/">至少是其他数字两倍的最大数</a></li></ol><h2 id="3-解题报告"><strong>3. 解题报告</strong></h2><p><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></p><p><strong>题目描述</strong></p><blockquote><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p></blockquote><p><strong>解题思路</strong></p><p>使用冒泡排序将数组按升序排列，排完序后相同的数就会相邻。</p><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i) &#123;  <span class="comment">//因为每次比较两个数，所以总共n个数，只需要比较n-1次（外循环n-1次）</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; ++j) &#123;  <span class="comment">//每次比较完后，最大的值在下一次比较中不用比较，所以每次比较只需要循环n-1-i 次（内循环n-1-i次）</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    bubbleSort(nums, numsSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="剩下的题目大同小异，在此不多做展示。">剩下的题目大同小异，在此不多做展示。</h5>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Bubble Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2023/11/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>插入排序</h1><h3 id="1-概念定义"><strong>1. 概念定义</strong></h3><p><strong>插入排序</strong>（Insertion Sort），一般也被称为直接插入排序，是一种简单直观的排序算法。</p><p><strong>工作原理</strong>：将待排列元素划分为「已排序」和「未排序」两部分，每次从「未排序的」元素中选择一个插入到「已排序的」元素中的正确位置。</p><p>这个过程类似于平时打扑克牌时摸牌的操作：右手摸牌，根据牌面大小，放到左手中正确的位置。</p><p><a href="https://gitee.com/LowProfile666/image-bed/raw/master/img/insertion-sort-1-animate-example.svg">这里有张动图，但是好像放不上来</a></p><p>比如：1 2 6 3 4 7 5 ，将其从小到大排序。</p><p>第一次参与排序的数据：2 6 3 4 7 5（因为最开始没有[已排序的]，所以第一个数可以直接作为[已排序的]）</p><p>第一次循环：</p><p>当前的数：2</p><p>当前已有序列表：1</p><p>2 &gt; 1 : 2 放在 1 之后</p><p>第二次参与排序的数据：6 3 4 7 5</p><p>第二次循环：</p><p>当前的数：6</p><p>当前已有序列表：1 2</p><p>6 &gt; 2 : 6 放在 2 之后</p><p>第三次参与排序的数据：3 4 7 5</p><p>第三次循环：</p><p>当前的数：3</p><p>当前已有序列表：1 2 6</p><p>3 &lt; 6 :</p><p>3 &gt; 2 : 3 放在 2 之后</p><p>第四次参与排序的数据：4 7 5</p><p>第四次循环：</p><p>当前的数：4</p><p>当前已有序列表：1 2 3 6</p><p>4 &lt; 6 :</p><p>4 &gt; 3 : 4 放在 3 之后</p><p>第五次参与排序的数据：7 5</p><p>第五次循环：</p><p>当前的数：7</p><p>当前已有序列表：1 2 3 4 6</p><p>7 &gt; 6 : 7 放在 6 之后</p><p>第六次参与排序的数据：5</p><p>第六次循环：</p><p>当前的数：5</p><p>当前已有序列表：1 2 3 4 6 7</p><p>5 &lt; 7 :</p><p>5 &lt; 6 :</p><p>5 &gt; 4 : 5 放在 4 之后</p><p>至此，数据全部排序为：1 2 3 4 5 6 7</p><p><strong>具体实现</strong>：使用双层循环，外层循环枚举除了第一个元素之外的所有元素，内层循环遍历当前元素前面的有序表，进行待插入位置查找，并进行移动。时间复杂度为O(n^2^)，空间复杂度为O(1)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> *number, <span class="type">int</span> n)</span>    <span class="comment">//定义一个插入函数&quot;insertionSort&quot; </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">//循环遍历 </span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = number[i];  <span class="comment">//将tmp每一次赋值为number[i]  </span></span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)  <span class="comment">//比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; number[j]) number[j+<span class="number">1</span>] = number[j];  <span class="comment">//更小交换</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        number[j+<span class="number">1</span>] = tmp;   <span class="comment">//否则添加到最后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题目练习"><strong>2. 题目练习</strong></h3><ol><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组（基础题）</a></li><li><a href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序（提高题）</a></li></ol><h3 id="3-解题报告"><strong>3. 解题报告</strong></h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a></p><p><strong>题目描述</strong></p><blockquote><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p></blockquote><p><strong>解题思路</strong></p><p>先将 nums2 的元素放到 nums1 里去，然后对整个 nums1 数组进行插入排序。</p><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> *number, <span class="type">int</span> n)</span>    <span class="comment">//定义一个插入函数&quot;insertionSort&quot; </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">//循环遍历 </span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = number[i];  <span class="comment">//将tmp每一次赋值为number[i]  </span></span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)  <span class="comment">//比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; number[j]) number[j+<span class="number">1</span>] = number[j];  <span class="comment">//更小交换</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        number[j+<span class="number">1</span>] = tmp;   <span class="comment">//否则添加到最后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span> m, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i,j= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = m; i &lt; m+n; i++)  <span class="comment">//合并数组</span></span><br><span class="line">    &#123;  </span><br><span class="line">        nums1[i] = nums2[j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = m + n;</span><br><span class="line">    insertionSort(nums1, size);  <span class="comment">//排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序</a></p><p><strong>题目描述</strong></p><blockquote><p>给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。</p></blockquote><p><strong>解题思路</strong></p><p>利用直接插入排序的算法思想，单链表无法向前遍历，需要通过三个指针完成操作。</p><p><strong>C代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">insertionSortList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)                                                        <span class="comment">//链表为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">L</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode)); <span class="comment">//辅助结点</span></span><br><span class="line">    L-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head-&gt;next, *pre = head, *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;                                                     <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val &gt;= pre-&gt;val)&#123;                                           <span class="comment">//寻找需要向前插入的结点</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp = L;</span><br><span class="line">            <span class="keyword">while</span>(tmp-&gt;next-&gt;val &lt; cur-&gt;val)                                <span class="comment">//寻找插入位置</span></span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            pre-&gt;next = cur-&gt;next;                                          <span class="comment">//进行插入</span></span><br><span class="line">            cur-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = cur;</span><br><span class="line">            cur = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Insertion Sort </tag>
            
            <tag> Link List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2023/11/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/11/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>选择排序</h1><p>直观且简单的一种排序，将未排序的头个元素与后面的比较，选择最小的放到最前。时间复杂度为O(n^2^)，空间复杂度为O(1)。</p><p>例如：[4, 7, 2, 5]   ——&gt; 将4与后面的7, 2, 5比较——&gt; 把最小的2与4的位置调换 ——&gt; 将第二位的7与后面的数字比较 ——&gt; 将7与后面数字中最小的4调换 …… 以此类推。</p><h5 id="代码实现：">代码实现：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void selectionSort(int* nums, int numsSize) &#123;</span><br><span class="line">    int i, j, min;</span><br><span class="line">    for(i = 0; i &lt; numsSize - 1; ++i) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        for(j = i + 1; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            if(nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp = nums[min];</span><br><span class="line">        nums[min] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="题目链接：">题目链接：</h5><p><a href="https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/">判断能否形成等差数列</a></p><p><a href="https://leetcode.cn/problems/largest-number-at-least-twice-of-others/">至少是其他数字两倍的最大数</a></p><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></p><p><a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></p><h5 id="题解：">题解：</h5><p>4道题目均可以采用调用排序函数后对排序过的数组进行操作得出答案，由于较为简单，因此就不放题解了~</p><p>（绝对不是因为偷懒，绝对不是！）</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Daily Training </tag>
            
            <tag> Selection Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome! This is my first blog.</title>
      <link href="/2023/11/02/Welcome-This-is-my-first-blog/"/>
      <url>/2023/11/02/Welcome-This-is-my-first-blog/</url>
      
        <content type="html"><![CDATA[<h1>Welcome!</h1><p>Welcome to my blog!</p><p>I will post some articles here. They might be useful, but I think most of them will be useless but funny. My native language is Chinese, so most of the articles will be written in Chinese. But I may translate some of them into English in order to improve my ability.</p><p>Thank you for spending time reading. See you again!</p>]]></content>
      
      
      <categories>
          
          <category> English Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Start </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到我的博客！</title>
      <link href="/2023/11/02/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81/"/>
      <url>/2023/11/02/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1>欢迎！</h1><p>我希望在这里分享一些有用或者有趣的东西。</p><p>作为一名技术小白，我希望有一个地方能够记录我的成长，并且同时能够帮助一些有需要的人。所以想到了搭建一个属于我自己的博客。在查阅了众多资料、解决了各种困难后，这个网站终于初现雏形。虽然他现在还很简陋，但是我相信随着我的进步，他一定会更加完善，最后变成一个优雅的个人博客。我很期待那一天的到来。</p><p>也欢迎大家访问、留言（后面会开放的……吧），希望能与小白共同成长，让大犇驻足相助~</p><h6 id="博客0-0测试版（因为当时没有截图所以找了一张相近的顶一下）">博客0.0测试版（因为当时没有截图所以找了一张相近的顶一下）</h6><p><img src="https://s2.loli.net/2023/11/02/3apnkItSCyvBVQD.jpg" alt="屏幕截图 2023-11-02 172526.jpg"></p><h6 id="博客1-0测试版">博客1.0测试版</h6><p><img src="https://s2.loli.net/2023/11/02/m7IPrzYM9tB6yFl.jpg" alt="屏幕截图 2023-11-02 172200.jpg"></p><h6 id="博客1-1发布版">博客1.1发布版</h6><p><img src="https://s2.loli.net/2023/11/02/yxGDq8OVnbvKjc3.png" alt="屏幕截图 2023-11-02 180941.png"></p>]]></content>
      
      
      <categories>
          
          <category> 岁月史书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Start </tag>
            
            <tag> History </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/01/hello-world/"/>
      <url>/2023/11/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to a website created with <a href="https://hexo.io/">Hexo</a>! This is the very first post. To memorialize it, I named him “Hello World”.</p><p>Check <a href="https://hexo.io/docs/">documentation</a> for more info. If  get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="PS">PS:</h2><p>As you can see, this article is mostly created by Hoxe, a useful tool to build a blog. I keep this page not only   to show my gratitude, but also to help me when I forget how to use it. If you also want to set up a personal blog, you can try it! And remember, the official manual is always the best choice when you want to learn something.</p>]]></content>
      
      
      <categories>
          
          <category> English Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Start </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
